<OPTIONS>
    <FILTERS>
        <vf separator=",">
            <opt name="crop" separator=":" description="&lt;b&gt;crop[=w:h:x:y]&lt;/b&gt; Crops the given part of the image and discards the rest.&lt;br&gt;Useful to remove black bands from widescreen movies.">
		    <subopt name="w" type="int" min="0" max="1000" default="$CROPWIDTH" special="$CROPWIDTH" description="Cropped width and height, defaults to original width and height."/>
		    <subopt name="h" type="int" min="0" max="1000" default="$CROPHEIGHT" special="$CROPHEIGHT" description="Cropped width and height, defaults to original width and height."/>
		    <subopt name="x" type="int" min="0" max="1000" default="$CROPLEFT" special="$CROPLEFT" description="Position of the cropped picture, defaults to center."/>
		    <subopt name="y" type="int" min="0" max="1000" default="$CROPTOP"  special="$CROPTOP" description="Position of the cropped picture, defaults to center."/>
            </opt>
            <opt name="cropdetect" separator=":" description="Calculates necessary cropping parameters and prints the recommended parameters to stdout.">
                <subopt name="limit" type="int" min="0" max="255" default="24" description="limit : Threshold, which can be optionally specified from nothing (0) to everything (255) (default: 24)."/>
                <subopt name="round" type="int" min="0" max="255" default="16" description="round : Value which the width/height should be divisible by (default: 16).&lt;br&gt; The offset is automatically adjusted to center the video. Use 2 to get only even dimensions (needed for 4:2:2 video). 16 is best when encoding to most video codecs." />
             </opt>
             <opt name="expand" separator=":" description="Expands (not scales) movie resolution to the given value and places the unscaled original at coordinates x, y. Can be used for placing subtitles/OSD in the resulting black bands">
                 <subopt name="w" type="int" min="-1000" max="1000" default="0" description="Expanded width,height (default: original width,height).&lt;br&gt;Negative values for w and h are treated as offsets to the original size."/>
                 <subopt name="h" type="int" min="-1000" max="1000" default="0" description="Expanded width,height (default: original width,height).&lt;br&gt;Negative values for w and h are treated as offsets to the original size."/>
                 <subopt name="x" type="int" min="-1000" max="1000" default="0" description=" position of original image on the expanded image (default: center)"/>
                 <subopt name="y" type="int" min="-1000" max="1000" default="0" description=" position of original image on the expanded image (default: center)"/>
                 <subopt name="o" type="int" min="0" max="1" default="0" description="OSD/subtitle rendering &lt;br&gt;    0: disable (default)&lt;br&gt;    1: enable"/>
                 <subopt name="a" type="string" description="Expands to fit an aspect instead of a resolution (default: 0).&lt;br&gt;&lt;br&gt;EXAMPLE:&lt;br&gt;expand=800:::::4/3    Expands to 800x600, unless the source is higher resolution, in which case it expands to fill a 4/3 aspect." />
                 <subopt name="r" type="int" min="1" max="100" default="1" description="Rounds up to make both width and height divisible by r (default: 1)."/>
             </opt>
             <opt type="bool" name="flip" default="false" description="Flips the image upside down."/>
             <opt type="bool" name="mirror" default="false" description="Mirrors the image on the Y axis."/>
             <opt name="scale" separator=":" description="Scales the image with the software scaler (slow) and performs a YUV to RGB colorspace conversion (also see −sws)">
                 <subopt name="w" type="int" min="-11" max="10000" default="0" special="$WIDTH" description="scaled width/height (default: original width/height)&lt;br&gt;NOTE: If −zoom is used, and underlying filters (including libvo) are incapable of scaling, it defaults to d_width/d_height!&lt;br&gt;-  0: scaled d_width/d_height&lt;br&gt;-  -1: original width/height&lt;br&gt;-  -2: Calculate w/h using the other dimension and the prescaled aspect ratio.&lt;br&gt;-  -3: Calculate w/h using the other dimension and the original aspect ratio.&lt;br&gt;-  -(n+8): Like -n above, but rounding the dimension to the closest multiple of 16."/>
                     <subopt name="h" type="int" min="-11" max="10000" default="0" special="$HEIGHT"/>
                     <subtop name="ilaced" type="int" min="0" max="1" default="0" description="Toggle interlaced scaling.&lt;br&gt;-  0: off (default)&lt;br&gt;-  1: on"/>
                     <subopt name="chr_drop" type="int" min="0" max="3" default="0" description="chroma skipping&lt;br&gt;.  0: Use all available input lines for chroma.&lt;br&gt;.  1: Use only every 2. input line for chroma.&lt;br&gt;.  2: Use only every 4. input line for chroma.&lt;br&gt;.  3: Use only every 8. input line for chroma."/>
                     <subopt name="par" type="float"   min="0" max="100" default="0" description="(also see −sws) : Set some scaling parameters depending on the type of scaler selected with −sws.&lt;br&gt;−sws 2 (bicubic): B (blurring) and C (ringing)&lt;br&gt;0.00:0.60 default&lt;br&gt;0.00:0.75 VirtualDub’s 'precise bicubic'&lt;br&gt;0.00:0.50 Catmull-Rom spline&lt;br&gt;0.33:0.33 Mitchell-Netravali spline&lt;br&gt;1.00:0.00 cubic B-spline&lt;br&gt;−sws 7 (gaussian): sharpness (0 (soft) − 100 (sharp))&lt;br&gt;−sws 9 (lanczos): filter length (1−10)"/>
                     <subopt name="par2" type="float"   min="0" max="100" default="0"/>
                     <subopt name="presize" type="string" default="" description="Scale to preset sizes.&lt;br&gt;-  qntsc: 352x240 (NTSC quarter screen)&lt;br&gt;-  qpal: 352x288 (PAL quarter screen)&lt;br&gt;-  ntsc: 720x480 (standard NTSC)&lt;br&gt;.  pal: 720x576 (standard PAL)&lt;br&gt;-  sntsc: 640x480 (square pixel NTSC)&lt;br&gt;-  spal: 768x576 (square pixel PAL)">
                         <value name=""/>
                         <value name="qntsc"/>
                         <value name="qpal"/>
                         <value name="ntsc"/>
                         <value name="pal"/>
                         <value name="sntsc"/>
                         <value name="spal"/>
                     </subopt>
                     <subopt name="noup" type="integer" min="0" max="2" default="0" description="Disallow upscaling past the original dimensions.&lt;br&gt;- 0: Allow upscaling (default).&lt;br&gt;- 1: Disallow upscaling if one dimension exceeds its original value.&lt;br&gt;- 2: Disallow upscaling if both dimensions exceed their original values."/>
                     <subopt name="arnd" type="bool" default="false" description="Accurate rounding for the vertical scaler, which may be faster or slower than the default rounding.&lt;br&gt;- 0: Disable accurate rounding (default).&lt;br&gt;- 1: Enable accurate rounding."/>
             </opt>
             
             <opt name="dsize" separator=":" description="Changes the intended display size/aspect at an arbitrary point in the filter chain.&lt;br&gt;You may specify the exact display width and height desired. Note that this filter does not do any scaling itself; it just affects what later scalers (software or hardware) will do when auto-scaling to correct aspect.&lt;br &gt;">
                 <subopt name="aspect" type="string" default="" description="Aspect can be given as a fraction (4/3) or floating point number (1.33)."/>
                 <subopt name="h" type="int" min="-3" max="10000" default="-1" description="New display width and height. Can also be these special values:&lt;br&gt;-  0: original display width and height&lt;br&gt;-  -1: original video width and height (default)&lt;br&gt;-  -2: Calculate w/h using the other dimension and the original display aspect ratio.&lt;br&gt;-  -3: Calculate w/h using the other dimension and the original video aspect ratio.&lt;br&gt;&lt;br&gt;EXAMPLE:&lt;br&gt;dsize=800:-2&lt;br&gt;Specifies a display resolution of 800x600 for a 4/3 aspect video, or 800x450 for a 16/9 aspect video."/>
                 <subopt name="w" type="int" min="-3" max="10000" default="0" description="New display width and height. Can also be these special values:&lt;br&gt;-  0: original display width and height&lt;br&gt;-  -1: original video width and height (default)&lt;br&gt;-  -2: Calculate w/h using the other dimension and the original display aspect ratio.&lt;br&gt;-  -3: Calculate w/h using the other dimension and the original video aspect ratio.&lt;br&gt;&lt;br&gt;EXAMPLE:&lt;br&gt;dsize=800:-2&lt;br&gt;Specifies a display resolution of 800x600 for a 4/3 aspect video, or 800x450 for a 16/9 aspect video."/>
                 <subopt name="aspect-method" type="int" min="-1" max="3" default="0" description="Modifies width and height according to original aspect ratios.&lt;br&gt;-  -1: Ignore original aspect ratio (default).&lt;br&gt;-  0: Keep display aspect ratio by using w and h as maximum resolution.&lt;br&gt;-  1: Keep display aspect ratio by using w and h as minimum resolution.&lt;br&gt;-  2: Keep video aspect ratio by using w and h as maximum resolution.&lt;br&gt;-  3: Keep video aspect ratio by using w and h as minimum resolution.&lt;br&gt;&lt;br&gt;EXAMPLE:&lt;br&gt;dsize=800:600:0&lt;br&gt;Specifies a display resolution of at most 800x600, or smaller, in order to keep aspect."/>
                 <subopt name="r" type="int" min="0" max="100" default="1" description="Rounds up to make both width and height divisible by r (default: 1)."/>
             </opt>
             <opt name="yuy2" type="bool" default="false" description="Forces software YV12/I420/422P to YUY2 conversion.&lt;br&gt;Useful for video cards/drivers with slow YV12 but fast YUY2 support."/>
             <opt name="yuv9" type="bool" default="false" description="Forces software YVU9 to YV12 colorspace conversion.&lt;br&gt;Deprecated in favor of the software scaler."/>
             <opt name="yuvcsp" type="bool" default="false" description="Clamps YUV color values to the CCIR 601 range without doing real conversion."/>
             <opt name="rgb2bgr" type="string" default="" description="RGB 24/32 − BGR 24/32 colorspace conversion.&lt;br&gt;swap : Also perform R - B swapping.">
                    <value name=""/>
                    <value name="swap"/>
             </opt>
             <opt name="palette" type ="bool" default="false" description="RGB/BGR 8 −> 15/16/24/32bpp colorspace conversion using palette."/>
             <opt name="format" type="string" default="yuy2" description="Restricts the colorspace for the next filter without doing any conversion. Use together with the scale filter for a real conversion.&lt;br&gt;NOTE: For a list of available formats see mencoder -vf format=fmt=help.&lt;br&gt;-  fourcc : format name like rgb15, bgr24, yv12, etc (default: yuy2)"/>
             <opt name="noformat" type="string" default="yv12" description="Restricts the colorspace for the next filter without doing any conversion. Unlike the format filter, this will allow any colorspace except the one you specify.&lt;br&gt;NOTE: For a list of available formats see noformat=fmt=help.&lt;br&gt;-  fourcc : format name like rgb15, bgr24, yv12, etc (default: yv12)"/>
             <opt name="pp" type="string" default="de" description="Enables the specified chain of postprocessing subfilters. Subfilters must be separated by ’/’ and can be disabled by prepending a ’−’. Each subfilter and some options have a short and a long name that can be used interchangeably, i.e. dr/dering are the same. All subfilters share common options to determine their scope:&lt;br&gt;- a/autoq : Automatically switch the subfilter off if the CPU is too slow.&lt;br&gt;- c/chrom : Do chrominance filtering, too (default).&lt;br&gt;- y/nochrom : Do luminance filtering only (no chrominance).&lt;br&gt;- n/noluma : Do chrominance filtering only (no luminance).&lt;br&gt;&lt;br&gt;NOTE: −pphelp shows a list of available subfilters.&lt;br&gt;Available subfilters are&lt;br&gt;-  hb/hdeblock[:difference[:flatness]] : horizontal deblocking filter&lt;br&gt;.....&bnsp;difference: Difference factor where higher values mean more deblocking (default: 32).&lt;br&gt;.....&bnsp;flatness : Flatness threshold where lower values mean more deblocking (default: 39).&lt;br&gt;.....&bnsp;vb/vdeblock[:difference[:flatness]] : vertical deblocking filter&lt;br&gt;.....&bnsp;difference : Difference factor where higher values mean more deblocking (default: 32).&lt;br&gt;.....&bnsp;flatness : Flatness threshold where lower values mean more deblocking (default: 39).&lt;br&gt;-  ha/hadeblock[:difference[:flatness]] : accurate horizontal deblocking filter&lt;br&gt;.....&bnsp;difference : Difference factor where higher values mean more deblocking (default: 32).&lt;br&gt;.....&bnsp;flatness : Flatness threshold where lower values mean more deblocking (default: 39).&lt;br&gt;-  va/vadeblock[:difference[:flatness]] : accurate vertical deblocking filter&lt;br&gt;.....&bnsp;difference: Difference factor where higher values mean more deblocking (default: 32).&lt;br&gt;.....&bnsp;flatness : Flatness threshold where lower values mean more deblocking (default: 39).&lt;br&gt;The horizontal and vertical deblocking filters share the difference and flatness values so you cannot set different horizontal and vertical thresholds.&lt;br&gt;-  h1/x1hdeblock : experimental horizontal deblocking filter&lt;br&gt;-  v1/x1vdeblock : experimental vertical deblocking filter&lt;br&gt;-  dr/dering : deringing filter&lt;br&gt;-  tn/tmpnoise[:threshold1[:threshold2[:threshold3]]] : temporal noise reducer&lt;br&gt;.....&bnsp;threshold1: larger -> stronger filtering&lt;br&gt;.....&bnsp; threshold2: larger -> stronger filtering&lt;br&gt;threshold3 : larger -> stronger filtering&lt;br&gt;-  al/autolevels[:f/fullyrange] : automatic brightness / contrast correction&lt;br&gt;-  f/fullyrange: Stretch luminance to (0−255).&lt;br&gt;-  lb/linblenddeint : Linear blend deinterlacing filter that deinterlaces the given block by filtering all lines with a (1 2 1) filter.&lt;br&gt;-  li/linipoldeint : Linear interpolating deinterlacing filter that deinterlaces the given block by linearly interpolating every second line.&lt;br&gt;-  ci/cubicipoldeint : Cubic interpolating deinterlacing filter deinterlaces the given block by cubically interpolating every second line.&lt;br&gt;-  md/mediandeint : Median deinterlacing filter that deinterlaces the given block by applying a median filter to every second line.&lt;br&gt;-  fd/ffmpegdeint : FFmpeg deinterlacing filter that deinterlaces the given block by filtering every second line with a (-1 4 2 4 -1) filter.&lt;br&gt;-  l5/lowpass5 : Vertically applied FIR lowpass deinterlacing filter that deinterlaces the given block by filtering all lines with a (-1 2 6 2 -1) filter.&lt;br&gt;-  fq/forceQuant[:quantizer] : Overrides the quantizer table from the input with the constant quantizer you specify.&lt;br&gt;.....&bnsp;quantizer: quantizer to use&lt;br&gt;-  de/default : default pp filter combination (hb:a,vb:a,dr:a)&lt;br&gt;-  fa/fast : fast pp filter combination (h1:a,v1:a,dr:a)&lt;br&gt;-  ac : high quality pp filter combination (ha:a:128:7,va:a,dr:a)&lt;br&gt;EXAMPLE:&lt;br&gt;−vf pp=hb/vb/dr/al : horizontal and vertical deblocking, deringing and automatic brightness/contrast&lt;br&gt;−vf pp=de/-al : default filters without brightness/contrast correction&lt;br&gt;−vf pp=default/tmpnoise:1:2:3 : Enable default filters and temporal denoiser.&lt;br&gt;−vf pp=hb:y/vb:a : Horizontal deblocking on luminance only, and switch vertical deblocking on or off automatically depending on available CPU time."/>
             <opt name="spp" separator=":" description="Simple postprocessing filter that compresses and decompresses the image at several (or − in the case of quality level 6 − all) shifts and averages the results.">
                 <subopt name="quality" type="int" min="0" max="6" default="3" description="0−6 (default: 3)"/>
                 <subopt name="qp" type="int" min="0" max="100" default="0" description="Force quantization parameter (default: 0, use QP from video)."/>
                 <subopt name="mode" type="string" default="0" description="0: hard thresholding (default)&lt;br&gt;1: soft thresholding (better deringing, but blurrier)&lt;br&gt;4: like 0, but also use B-frames’ QP (may cause flicker)&lt;br&gt;5: like 1, but also use B-frames’ QP (may cause flicker)">
                     <value name="0"/>
                     <value name="1"/>
                     <value name="4"/>
                     <value name="5"/>
                 </subopt>
             </opt>
             <opt name="uspp" separator=":" description="Ultra simple and slow postprocessing filter that compresses and decompresses the image at several (or − in the case of quality level 8 − all) shifts and averages the results.&lt;br&gt;The way this differs from the behavior of spp is that uspp actually encodes and decodes each case with libavcodec Snow, whereas spp uses a simplified intra only 8x8 DCT similar to MJPEG.">
                 <subopt name="quality" type="int" min="0" max="8" default="3" description="0−8 (default: 3)"/>
                 <subopt name="qp" type="int" min="0" max="100" default="0" description="Force quantization parameter (default: 0, use QP from video)."/>
             </opt>
             <opt name="fspp" separator=":" description="faster version of the simple postprocessing filter">
                 <subopt name="quality" type="int" min="4" max="5" default="4" description="4−5 (equivalent to spp; default: 4)"/>
                 <subopt name="qp" type="int" min="0" max="100" default="0" description="Force quantization parameter (default: 0, use QP from video)."/>
                 <subopt name="strength" type="int" min="-15" max="32" default="0" description="Filter strength, lower values mean more details but also more artifacts,&lt;br&gt;while higher values make the image smoother but also blurrier (default: 0 − PSNR optimal)."/>
                 <subopt name="bframes" type="int" min="0" max="1" default="0" description="0: do not use QP from B-frames (default)&lt;br&gt;1: use QP from B-frames too (may cause flicker)"/>
             </opt>
             <opt name="pp7" separator=":" description="Variant of the spp filter, similar to spp=6 with 7 point DCT where only the center sample is used after IDCT.">
                 <subopt name="qp" type="int" min="0" max="100" default="0" description="Force quantization parameter (default: 0, use QP from video)."/>
                 <subopt name="mode" type="int" min="0" max="2" default="2" description="0: hard thresholding&lt;br&gt;1: soft thresholding (better deringing, but blurrier)&lt;br&gt;2: medium thresholding (default, good results)"/>
             </opt>
             <opt name="qp" type="string" default="" description="quantization parameter (QP) change filter&lt;br&gt;equation : some equation like '2+2*sin(PI*qp)'"/>
             <opt name="geq" type="string" default="" description="generic equation change filter&lt;br&gt;equation&lt;br&gt;Some equation, e.g. ’p(W-XY)’ to flip the image horizontally. You can use whitespace to make the equation more readable. There are a couple of constants that can be used in the equation:&lt;br&gt;....PI: the number pi&lt;br&gt;....E: the number e&lt;br&gt;....X / Y: the coordinates of the current sample&lt;br&gt;....W / H: width and height of the image&lt;br&gt;....SW / SH: width/height scale depending on the currently filtered plane, e.g. 1,1 and 0.5,0.5 for YUV 4:2:0.&lt;br&gt;....p(x,y): returns the value of the pixel at location x/y of the current plane."/>
             <opt name="test" type="bool" default="false" description="Generate various test patterns."/>
             <opt name="rgbtest" type="bool" default="false" description="Generate an RGB test pattern useful for detecting RGB vs BGR issues.&lt;br&gt;You should see a red, green and blue stripe from top to bottom."/>
             <opt name="lavc" separator=":" description="Fast software YV12 to MPEG-1 conversion with libavcodec for use with DVB/DXR3/IVTV.">   
                 <subopt name="quality" type="int" min="1" max="32" default="32" description="1−31: fixed qscale&lt;br&gt;32−: fixed bitrate in kbits"/>
                 <subopt name="fps" type="int" min="0" max="50" default="0" description="force output fps (float value) (default: 0, autodetect based on height)"/>
             </opt>
             <opt name="dvbscale" type="string" default="" description="Set up optimal scaling for DVB cards, scaling the x axis in hardware and calculating the y axis scaling in software to keep aspect. Only useful together with expand and scale.&lt;br&gt;Control aspect ratio, calculate as DVB_HEIGHT*ASPECTRATIO (default: 576*4/3=768), set it to 576*(16/9)=1024 for a 16:9 TV."/>
             <opt name="noise" type="string" default="" description="&lt;b&gt;luma[u][t|a][h][p]:chroma[u][t|a][h][p]]&lt;/b&gt;&lt;br&gt;Adds noise.&lt;br&gt;0−100 : luma noise&lt;br&gt;0−100 : chroma noise&lt;br&gt;u : uniform noise (gaussian otherwise)&lt;br&gt;t : temporal noise (noise pattern changes between frames)&lt;br&gt;a	:averaged temporal noise (smoother, but a lot slower)&lt;br&gt;h	:high quality (slightly better looking, slightly slower)&lt;br&gt;p	: mix random noise with a (semi)regular pattern"/>
             <opt name="denoise3d" separator=":" description="This filter aims to reduce image noise producing smooth images and making still images really still (This should enhance compressibility.).">
                 <subopt name="luma_spatial" type="int" min="0" max="100" default="4" description="spatial luma strength (default: 4)"/>
                 <subopt name="chroma_spatial" type="int" min="0" max="100" default="3" description="spatial chroma strength (default: 3)"/>
                 <subopt name="luma_tmp" type="int" min="0" max="100" default="6" description="luma temporal strength (default: 6)"/>
                 <subopt name="chroma_tmp" type="int" min="0" max="100" default="4" description="chroma temporal strength (default: luma_tmp*chroma_spatial/luma_spatial)"/>
             </opt>
             <opt name="hqdn3d" separator=":" description="High precision/quality version of the denoise3d filter. Parameters and usage are the same.">
                 <subopt name="luma_spatial" type="int" min="0" max="100" default="4" description="spatial luma strength (default: 4)"/>
                 <subopt name="chroma_spatial" type="int" min="0" max="100" default="3" description="spatial chroma strength (default: 3)"/>
                 <subopt name="luma_tmp" type="int" min="0" max="100" default="6" description="luma temporal strength (default: 6)"/>
                 <subopt name="chroma_tmp" type="int" min="0" max="100" default="4" description="chroma temporal strength (default: luma_tmp*chroma_spatial/luma_spatial)"/>
             </opt>
             <opt name="eq" separator=":" description="OBSOLETE !!&lt;br&gt;Software equalizer with interactive controls just like the hardware equalizer, for cards/drivers that do not support brightness and contrast controls in hardware.&lt;br&gt;Might also be useful with MEncoder, either for fixing poorly captured movies, or for slightly reducing contrast to mask artifacts and get by with lower bitrates.">
                 <subopt name="brightness" type="int" min="-100" max="100" default="0" description="initital brightness"/>
                 <subopt name="contrast" type="int" min="-100" max="100" default="0" description="initial contrast"/>
             </opt>
             <opt name="eq2" separator=":" description="Alternative software equalizer that uses lookup tables (very slow), allowing gamma correction in addition to simple brightness and contrast adjustment.&lt;br&gt;Note that it uses the same MMX optimized code as −vf eq if all gamma values are 1.0. The parameters are given as floating point values.">
                 <subopt name="gamma" type="float" min="0.1" max="10." default="1.0" description="initial gamma value (default: 1.0)"/>
                 <subopt name="contrast" type="float" min="-2.0" max="2.0" default="1.0" description="initial contrast, where negative values result in a negative image (default: 1.0)"/>
                 <subopt name="brightness" type="float" min="-1.0" max="1.0" default="0.0" description="initial brightness (default: 0.0)"/>
                 <subopt name="saturation" type="float" min="0.0" max="3.0" default="1.0" description="initial saturation (default: 1.0)"/>
                 <subopt name="rg" type="float" min="0.1" max="10.0" default="1.0" description="gamma value for the red component (default: 1.0)"/>
                 <subopt name="gg" type="float" min="0.1" max="10.0" default="1.0" description="gamma value for the green component (default: 1.0)"/>
                 <subopt name="bg" type="float" min="0.1" max="10.0" default="1.0" description="gamma value for the blue component (default: 1.0)"/>
                 <subopt name="weight" type="float" min="0.0" max="1.0" default="1.0" description="The weight parameter can be used to reduce the effect of a high gamma value on bright image areas, e.g. keep them from getting overamplified and just plain white.&lt;br&gt;A value of 0.0 turns the gamma correction all the way down while 1.0 leaves it at its full strength (default: 1.0)."/>
             </opt>
             <opt name="hue" separator=":" description="Software equalizer with interactive controls just like the hardware equalizer, for cards/drivers that do not support hue and saturation controls in hardware.">
                 <subopt name="hue" type="float" min="-180.0" max="180.0" default="0.0" description="initial hue (default: 0.0)"/>
                 <subopt name="saturation" type="float" min="-100.0" max="100.0" default="0.0" description="initial saturation, where negative values result in a negative chroma (default: 1.0)"/>
             </opt>
             <opt name="halfpack" type="int" min="0" max="100" default="0" description="Convert planar YUV 4:2:0 to half-height packed 4:2:2, downsampling luma but keeping all chroma samples.&lt;br&gt;Useful for output to low-resolution display devices when hardware downscaling is poor quality or is not available. Can also be used as a primitive luma-only deinterlacer with very low CPU usage.&lt;br&gt;&lt;br&gt;By default, halfpack averages pairs of lines when downsampling. Any value different from 0 or 1 gives the default (averaging) behavior.&lt;br&gt;- 0: Only use even lines when downsampling.&lt;br&gt;- 1: Only use odd lines when downsampling."/>
             <opt name="ilpack" type="int" min="0" max="1" default="1" description="When interlaced video is stored in YUV 4:2:0 formats, chroma interlacing does not line up properly due to vertical downsampling of the chroma channels. This filter packs the planar 4:2:0 data into YUY2 (4:2:2) format with the chroma lines in their proper locations, so that in any given scanline, the luma and chroma data both come from the same field.&lt;br&gt;&lt;br&gt;Select the sampling mode.&lt;br&gt;- 0: nearest-neighbor sampling, fast but incorrect&lt;br&gt;- 1: linear interpolation (default)"/>
             <opt name="harddup" type="bool" default="false" description="Only useful with MEncoder. If harddup is used when encoding, it will force duplicate frames to be encoded in the output.&lt;br&gt;This uses slightly more space, but is necessary for output to MPEG files or if you plan to demux and remux the video stream after encoding. Should be placed at or near the end of the filter chain unless you have a good reason to do otherwise."/>
             <opt name="softskip" type="bool" default="false" description="Only useful with MEncoder. Softskip moves the frame skipping (dropping) step of encoding from before the filter chain to some point during the filter chain.&lt;br&gt;This allows filters which need to see all frames (inverse telecine, temporal denoising, etc.) to function properly. Should be placed after the filters which need to see all frames and before any subsequent filters that are CPU-intensive."/>
             <opt name="decimate" separator=":" description="Drops frames that do not differ greatly from the previous frame in order to reduce framerate. The main use of this filter is for very-low-bitrate encoding (e.g. streaming over dialup modem), but it could in theory be used for fixing movies that were inverse-telecined incorrectly.">
                 <subopt name="max" min="-100" max="100" default="0" description="Sets the maximum number of consecutive frames which can be dropped (if positive), or the minimum interval between dropped frames (if negative)."/>
                 <subopt name="hi" min="-100" max="100" default="0" description="A frame is a candidate for dropping if no 8x8 region differs by more than a threshold of hi, and if not more than frac portion (1 meaning the whole image) differs by more than a threshold of lo. Values of hi and lo are for 8x8 pixel blocks and represent actual pixel value differences, so a threshold of 64 corresponds to 1 unit of difference for each pixel, or the same spread out differently over the block."/>
                 <subopt name="lo" min="-100" max="100" default="0" description="A frame is a candidate for dropping if no 8x8 region differs by more than a threshold of hi, and if not more than frac portion (1 meaning the whole image) differs by more than a threshold of lo. Values of hi and lo are for 8x8 pixel blocks and represent actual pixel value differences, so a threshold of 64 corresponds to 1 unit of difference for each pixel, or the same spread out differently over the block."/>
                 <subopt name="frac" min="-100" max="100" default="0" description="A frame is a candidate for dropping if no 8x8 region differs by more than a threshold of hi, and if not more than frac portion (1 meaning the whole image) differs by more than a threshold of lo. Values of hi and lo are for 8x8 pixel blocks and represent actual pixel value differences, so a threshold of 64 corresponds to 1 unit of difference for each pixel, or the same spread out differently over the block."/>
             </opt>
             <opt name="dint" separator=":" description="The drop-deinterlace (dint) filter detects and drops the first from a set of interlaced video frames.">
                 <subopt name="sense" type="float" min="0.0" max="1.0" default="0.1" description="relative difference between neighboring pixels (default: 0.1)"/>
                 <subopt name="level" type="float" min="0.0" max="1.0" default="0.15" description="What part of the image has to be detected as interlaced to drop the frame (default: 0.15)."/>
             </opt>
             <opt name="kerndeint" separator=":" description="Donald Graft’s adaptive kernel deinterlacer.&lt;br&gt;Deinterlaces parts of a video if a configurable threshold is exceeded.">
                 <subopt name="thresh" type="int" min="0" max="255" default="10" description="threshold (default: 10)"/>
                 <subopt name="map" type="int" min="0" max="1" default="0" description="0: Ignore pixels exceeding the threshold (default).&lt;br&gt;1: Paint pixels exceeding the threshold white."/>
                 <subopt name="order" type="int" min="0" max="1" default="0" description="0: Leave fields alone (default).&lt;br&gt;1: Swap fields."/>
                 <subopt name="sharp" type="int" min="0" max="1" default="0" description="0: Disable additional sharpening (default).&lt;br&gt;1: Enable additional sharpening."/>
                 <subopt name="twoway" type="int" min="0" max="1" default="0" description="0: Disable twoway sharpening (default).&lt;br&gt;1: Enable twoway sharpening."/>
             </opt>
             <opt name="unsharp" type="string" default="" description="&lt;b&gt;unsharp[=l|cWxH:amount[:l|cWxH:amount]]&lt;/b&gt;&lt;br&gt;unsharp mask / gaussian blur&lt;br&gt;- l : Apply effect on luma component.&lt;br&gt;- c : Apply effect on chroma components.&lt;br&gt;- |width|x|height| : width and height of the matrix, odd sized in both directions (min = 3x3, max = 13x11 or 11x13, usually something between 3x3 and 7x7)&lt;br&gt;- amount : Relative amount of sharpness/blur to add to the image (a sane range should be -1.5−1.5). less than 0: blur | greater than 0: sharpen"/>
             <opt name="swapuv" type="bool" default="false" description="Swap U and V plane."/>
             <opt name="il" separator=":" description="De)interleaves lines. The goal of this filter is to add the ability to process interlaced images pre-field without deinterlacing them.&lt;br&gt;You can filter your interlaced DVD and play it on a TV without breaking the interlacing. While deinterlacing (with the postprocessing filter) removes interlacing permanently (by smoothing, averaging, etc) deinterleaving splits the frame into 2 fields (so called half pictures), so you can process (filter) them independently and then re-interleave them.">
                 <subopt name="-" type="string" default="" description="d : deinterleave (placing one above the other)&lt;br&gt;i : interleave&lt;br&gt;s : swap fields (exchange even and odd lines)">
                     <value name=""/>
                     <value name="d"/>
                     <value name="i"/>
                     <value name="s"/>
                 </subopt>
                 <subopt name="-" type="string" default="" description="d : deinterleave (placing one above the other)&lt;br&gt;i : interleave&lt;br&gt;s : swap fields (exchange even and odd lines)">
                     <value name=""/>
                     <value name="d"/>
                     <value name="i"/>
                     <value name="s"/>
                 </subopt>
             </opt>
             <opt name ="fil" type="string"  default="d" description="(De)interleaves lines. This filter is very similar to the il filter but much faster, the main disadvantage is that it does not always work. Especially if combined with other filters it may produce randomly messed up images, so be happy if it works but do not complain if it does not for your combination of filters.&lt;br&gt;- d : Deinterleave fields, placing them side by side.&lt;br&gt;- i : Interleave fields again (reversing the effect of fil=d).">
                 <value name="d"/>
                 <value name="i"/>
             </opt>
             <opt name="field" type="int" min="1" max="2" default=" " special=" " description="Extracts a single field from an interlaced image using stride arithmetic to avoid wasting CPU time.&lt;br&gt;The optional argument n specifies whether to extract the even or the odd field (depending on whether n is even or odd)."/>
             <opt name="detc" separator=":" description="Attempts to reverse the ’telecine’ process to recover a clean, non-interlaced stream at film framerate.&lt;br&gt;This was the first and most primitive inverse telecine filter to be added to MPlayer/MEncoder. It works by latching onto the telecine 3:2 pattern and following it as long as possible. This makes it suitable for perfectly-telecined material, even in the presence of a fair degree of noise, but it will fail in the presence of complex post-telecine edits. Development on this filter is no longer taking place, as ivtc, pullup, and filmdint are better for most applications. The following arguments (see syntax above) may be used to control detc’s behavior">
                 <subopt name="dr" type="int" min="0" max="2" default="0" prefix="dr=" description="Set the frame dropping mode.&lt;br&gt;0: Do not drop frames to maintain fixed output framerate (default).&lt;br&gt;1: Always drop a frame when there have been no drops or telecine merges in the past 5 frames.&lt;br&gt;2: Always maintain exact 5:4 input to output frame ratio.&lt;br&gt;NOTE: Use mode 1 or 2 with MEncoder."/>
                 <subopt name="am" type="int" min="0" max="1" default="1" prefix="am=" description="Analysis mode.&lt;br&gt;0: Fixed pattern with initial frame number specified by fr.&lt;br&gt;1: aggressive search for telecine pattern (default)"/>
                 <subopt name="fr" type="int" min="-1" max="4" default="0" prefix="fr=" description="Set initial frame number in sequence. 0−2 are the three clean progressive frames; 3 and 4 are the two interlaced frames. The default, -1, means ’not in telecine sequence’.&lt;br&gt; The number specified here is the type for the imaginary previous frame before the movie starts."/>
                 <subopt name="t0" type="int" min="0" max="100" default="0" prefix="t0=" description="Threshold values to be used in certain modes."/>
                 <subopt name="t1" type="int" min="0" max="100" default="0" prefix="t1="  description="Threshold values to be used in certain modes."/>
                 <subopt name="t2" type="int" min="0" max="100" default="0" prefix="t2="  description="Threshold values to be used in certain modes."/>
                 <subopt name="t3" type="int" min="0" max="100" default="0" prefix="t3="  description="Threshold values to be used in certain modes."/>
             </opt>
             <opt name="ivtc" type="int" min="1" max="1" default="1" description="Experimental ’stateless’ inverse telecine filter. Rather than trying to lock on to a pattern like the detc filter does, ivtc makes its decisions independently for each frame.&lt;br&gt;This will give much better results for material that has undergone heavy editing after telecine was applied, but as a result it is not as forgiving of noisy input, for example TV capture. The optional parameter (ivtc=1) corresponds to the dr=1 option for the detc filter, and should be used with MEncoder but not with MPlayer. As with detc, you must specify the correct output framerate (−ofps 24000/1001) when using MEncoder. Further development on ivtc has stopped, as the pullup and filmdint filters appear to be much more accurate."/>
             <opt name="pullup" separator=":" description="Third-generation pulldown reversal (inverse telecine) filter, capable of handling mixed hard-telecine, 24000/1001 fps progressive, and 30000/1001 fps progressive content.&lt;br&gt;The pullup filter is designed to be much more robust than detc or ivtc, by taking advantage of future context in making its decisions. Like ivtc, pullup is stateless in the sense that it does not lock onto a pattern to follow, but it instead looks forward to the following fields in order to identify matches and rebuild progressive frames. It is still under development, but believed to be quite accurate.&lt;br&gt;NOTE: Always follow pullup with the softskip filter when encoding to ensure that pullup is able to see each frame. Failure to do so will lead to incorrect output and will usually crash, due to design limitations in the codec/filter layer.">
                 <subopt name="jl" type="bool" default="false" description="These options set the amount of 'junk' to ignore at the left, right, top, and bottom of the image, respectively.&lt;br&gt;Left/right are in units of 8 pixels, while top/bottom are in units of 2 lines. The default is 8 pixels on each side."/>
                 <subopt name="jr" type="bool" default="false" description="These options set the amount of 'junk' to ignore at the left, right, top, and bottom of the image, respectively.&lt;br&gt;Left/right are in units of 8 pixels, while top/bottom are in units of 2 lines. The default is 8 pixels on each side."/>
                 <subopt name="jt" type="bool" default="false" description="These options set the amount of 'junk' to ignore at the left, right, top, and bottom of the image, respectively.&lt;br&gt;Left/right are in units of 8 pixels, while top/bottom are in units of 2 lines. The default is 8 pixels on each side."/>
                 <subopt name="jb" type="bool" default="false" description="These options set the amount of 'junk' to ignore at the left, right, top, and bottom of the image, respectively.&lt;br&gt;Left/right are in units of 8 pixels, while top/bottom are in units of 2 lines. The default is 8 pixels on each side."/>
                 <subopt name="sb" type="bool" default="false" description="Setting this option to 1 will reduce the chances of pullup generating an occasional mismatched frame, but it may also cause an excessive number of frames to be dropped during high motion sequences.&lt;br&gt;Conversely, setting it to -1 will make pullup match fields more easily. This may help processing of video where there is slight blurring between the fields, but may also cause there to be interlaced frames in the output."/>
                 <subopt name="mp" type="bool" default="false" description="This option may be set to 1 or 2 to use a chroma plane instead of the luma plane for doing pullup’s computations.&lt;br&gt;This may improve accuracy on very clean source material, but more likely will decrease accuracy, especially if there is chroma noise (rainbow effect) or any grayscale video. The main purpose of setting mp to a chroma plane is to reduce CPU load and make pullup usable in realtime on slow machines."/>
             </opt>
             <opt name="filmdint" type="string" default="" description="Inverse telecine filter, similar to the pullup filter above.&lt;br&gt;It is designed to handle any pulldown pattern, including mixed soft and hard telecine and limited support for movies that are slowed down or sped up from their original framerate for TV. Only the luma plane is used to find the frame breaks. If a field has no match, it is deinterlaced with simple linear approximation. If the source is MPEG-2, this must be the first filter to allow access to the field-flags set by the MPEG-2 decoder. Depending on the source MPEG, you may be fine ignoring this advice, as long as you do not see lots of 'Bottom-first field' warnings. With no options it does normal inverse telecine, and should be used together with mencoder −fps 30000/1001 −ofps 24000/1001. When this filter is used with mplayer, it will result in an uneven framerate during playback, but it is still generally better than using pp=lb or no deinterlacing at all. Multiple options can be specified separated by /.&lt;br&gt;crop=w:h:x:y&lt;br&gt;Just like the crop filter, but faster, and works on mixed hard and soft telecined content as well as when y is not a multiple of 4. If x or y would require cropping fractional pixels from the chroma planes, the crop area is extended. This usually means that x and y must be even.&lt;br&gt;&lt;br&gt;io=ifps:ofps&lt;br&gt;For each ifps input frames the filter will output ofps frames. The ratio of ifps/ofps should match the −fps/−ofps ratio. This could be used to filter movies that are broadcast on TV at a frame rate different from their original framerate.&lt;br&gt;&lt;br&gt;luma_only=n&lt;br&gt;If n is nonzero, the chroma plane is copied unchanged. This is useful for YV12 sampled TV, which discards one of the chroma fields.&lt;br&gt;&lt;br&gt;mmx2=n&lt;br&gt;On x86, if n=1, use MMX2 optimized functions, if n=2, use 3DNow! optimized functions, otherwise, use plain C. If this option is not specified, MMX2 and 3DNow! are auto-detected, use this option to override auto-detection.&lt;br&gt;&lt;br&gt;fast=n&lt;br&gt;The larger n will speed up the filter at the expense of accuracy. The default value is n=3. If n is odd, a frame immediately following a frame marked with the REPEAT_FIRST_FIELD MPEG flag is assumed to be progressive, thus filter will not spend any time on soft-telecined MPEG-2 content. This is the only effect of this flag if MMX2 or 3DNow! is available. Without MMX2 and 3DNow, if n=0 or 1, the same calculations will be used as with n=2 or 3. If n=2 or 3, the number of luma levels used to find the frame breaks is reduced from 256 to 128, which results in a faster filter without losing much accuracy. If n=4 or 5, a faster, but much less accurate metric will be used to find the frame breaks, which is more likely to misdetect high vertical detail as interlaced content.&lt;br&gt;&lt;br&gt;verbose=n&lt;br&gt;If n is nonzero, print the detailed metrics for each frame. Useful for debugging.&lt;br&gt;&lt;br&gt;dint_thres=n&lt;br&gt;Deinterlace threshold. Used during de-interlacing of unmatched frames. Larger value means less deinterlacing, use n=256 to completely turn off deinterlacing. Default is n=8.&lt;br&gt;&lt;br&gt;comb_thres=n&lt;br&gt;Threshold for comparing a top and bottom fields. Defaults to 128.&lt;br&gt;&lt;br&gt;diff_thres=n&lt;br&gt;Threshold to detect temporal change of a field. Default is 128.&lt;br&gt;&lt;br&gt;sad_thres=n&lt;br&gt;Sum of Absolute Difference threshold, default is 64."/>
             <opt name="softpulldown" type="bool" default="false" description="This filter works only correct with MEncoder and acts on the MPEG-2 flags used for soft 3:2 pulldown (soft telecine).&lt;br&gt;If you want to use the ivtc or detc filter on movies that are partly soft telecined, inserting this filter before them should make them more reliable."/>
             <opt name="divtc" type="string" default="" description="Inverse telecine for deinterlaced video. If 3:2-pulldown telecined video has lost one of the fields or is deinterlaced using a method that keeps one field and interpolates the other, the result is a juddering video that has every fourth frame duplicated.&lt;br&gt;This filter is intended to find and drop those duplicates and restore the original film framerate. When using this filter, you must specify −ofps that is 4/5 of the fps of the input file and place the softskip later in the filter chain to make sure that divtc sees all the frames. Two different modes are available: One pass mode is the default and is straightforward to use, but has the disadvantage that any changes in the telecine phase (lost frames or bad edits) cause momentary judder until the filter can resync again. Two pass mode avoids this by analyzing the whole video beforehand so it will have forward knowledge about the phase changes and can resync at the exact spot. These passes do not correspond to pass one and two of the encoding process. You must run an extra pass using divtc pass one before the actual encoding throwing the resulting video away. Use −nosound −ovc raw −o /dev/null to avoid wasting CPU power for this pass. You may add something like crop=2:2:0:0 after divtc to speed things up even more. Then use divtc pass two for the actual encoding. If you use multiple encoder passes, use divtc pass two for all of them. The options are:&lt;br&gt;pass=1|2 : Use two pass mode.&lt;br&gt;&lt;br&gt;file=filename : Set the two pass log filename (default: 'framediff.log').&lt;br&gt;&lt;br&gt;threshold=value : Set the minimum strength the telecine pattern must have for the filter to believe in it (default: 0.5). This is used to avoid recognizing false pattern from the parts of the video that are very dark or very still.&lt;br&gt;&lt;br&gt;window=numframes : &lt;br&gt;Set the number of past frames to look at when searching for pattern (default: 30). Longer window improves the reliability of the pattern search, but shorter window improves the reaction time to the changes in the telecine phase. This only affects the one pass mode. The two pass mode currently uses fixed window that extends to both future and past.&lt;br&gt;&lt;br&gt;phase=0|1|2|3|4 : Sets the initial telecine phase for one pass mode (default: 0). The two pass mode can see the future, so it is able to use the correct phase from the beginning, but one pass mode can only guess. It catches the correct phase when it finds it, but this option can be used to fix the possible juddering at the beginning. The first pass of the two pass mode also uses this, so if you save the output from the first pass, you get constant phase result.&lt;br&gt;&lt;br&gt;deghost=value : Set the deghosting threshold (0−255 for one pass mode, -255−255 for two pass mode, default 0). If nonzero, deghosting mode is used. This is for video that has been deinterlaced by blending the fields together instead of dropping one of the fields. Deghosting amplifies any compression artifacts in the blended frames, so the parameter value is used as a threshold to exclude those pixels from deghosting that differ from the previous frame less than specified value. If two pass mode is used, then negative value can be used to make the filter analyze the whole video in the beginning of pass-2 to determine whether it needs deghosting or not and then select either zero or the absolute value of the parameter. Specify this option for pass-2, it makes no difference on pass-1."/>
             <opt name="phase" separator=":" description="Delay interlaced video by one field time so that the field order changes. The intended use is to fix PAL movies that have been captured with the opposite field order to the film-to-video transfer">
                 <subopt name="option" type="string" default="t" description="- t : Capture field order top-first, transfer bottom-first. Filter will delay the bottom field.&lt;br&gt;- b	: Capture bottom-first, transfer top-first. Filter will delay the top field.&lt;br&gt;- p : Capture and transfer with the same field order. This mode only exists for the documentation of the other options to refer to, but if you actually select it, the filter will faithfully do nothing ;-)&lt;br&gt;- a : Capture field order determined automatically by field flags, transfer opposite. Filter selects among t and b modes on a frame by frame basis using field flags. If no field information is available, then this works just like u.&lt;br&gt;- u : Capture unknown or varying, transfer opposite. Filter selects among t and b on a frame by frame basis by analyzing the images and selecting the alternative that produces best match between the fields.&lt;br&gt;- T : Capture top-first, transfer unknown or varying. Filter selects among t and p using image analysis.&lt;br&gt;- B : Capture bottom-first, transfer unknown or varying. Filter selects among b and p using image analysis.&lt;br&gt;- A : Capture determined by field flags, transfer unknown or varying. Filter selects among t, b and p using field flags and image analysis. If no field information is available, then this works just like U. This is the default mode.&lt;br&gt;- U : Both capture and transfer unknown or varying. Filter selects among t, b and p using image analysis only.">
                     <value name="t"/>
                     <value name="b"/>
                     <value name="p"/>
                     <value name="a"/>
                     <value name="u"/>
                     <value name="T"/>
                     <value name="B"/>
                     <value name="A"/>
                     <value name="U"/>
                 </subopt>
                 <subopt name="v" type="bool" default="false" description="Verbose operation. Prints the selected mode for each frame and the average squared difference between fields for t, b, and p alternatives."/>
             </opt>
             <opt name="telecine" separator=":" description="">
                 <subopt name="start" type="bool" default="false" description="Apply 3:2 ’telecine’ process to increase framerate by 20%.&lt;br&gt;This most likely will not work correctly with MPlayer, but it can be used with ’mencoder −fps 30000/1001 −ofps 30000/1001 −vf telecine’. Both fps options are essential! (A/V sync will break if they are wrong.) The optional start parameter tells the filter where in the telecine pattern to start (0−3)."/>
             </opt>
             <opt name="tinterlace" type="int" min="0" max="4" default="0" description="Temporal field interlacing − merge pairs of frames into an interlaced frame, halving the framerate. Even frames are moved into the upper field, odd frames to the lower field. This can be used to fully reverse the effect of the tfields filter (in mode 0). Available modes are:&lt;br&gt;- 0 : Move odd frames into the upper field, even into the lower field, generating a full-height frame at half framerate.&lt;br&gt;- 1 : Only output odd frames, even frames are dropped; height unchanged.&lt;br&gt;- 2 : Only output even frames, odd frames are dropped; height unchanged.&lt;br&gt;- 3 : Expand each frame to full height, but pad alternate lines with black; framerate unchanged.&lt;br&gt;- 4 : Interleave even lines from even frames with odd lines from odd frames. Height unchanged at half framerate."/>
             <opt name="tfields" separator=":" description="Temporal field separation − split fields into frames, doubling the output framerate.&lt;br&gt;Like the telecine filter, tfields will only work properly with MEncoder, and only if both −fps and −ofps are set to the desired (double) framerate!">
                 <subopt name="mode" type="int" min="0" max="4" default="4" description="0: Leave fields unchanged (will jump/flicker).&lt;br&gt;1: Interpolate missing lines. (The algorithm used might not be so good.)&lt;br&gt;2: Translate fields by 1/4 pixel with linear interpolation (no jump).&lt;br&gt;4: Translate fields by 1/4 pixel with 4tap filter (higher quality) (default)."/>
                 <subopt name="field_dominance" type="int" min="-1" max="1" default="-1" description="(DEPRECATED)&lt;br&gt;-1: auto (default) Only works if the decoder exports the appropriate information and no other filters which discard that information come before tfields in the filter chain, otherwise it falls back to 0 (top field first).&lt;br&gt;0: top field first&lt;br&gt;1: bottom field first&lt;br&gt;NOTE: This option will possibly be removed in a future version. Use −field-dominance instead."/>
             </opt>
             <opt name="yadif" separator=":" description="Yet another deinterlacing filter">
                 <subopt name="mode" type="int" min="1" max="3" default="1" description="0: Output 1 frame for each frame.&lt;br&gt;1: Output 1 frame for each field.&lt;br&gt;2: Like 0 but skips spatial interlacing check.&lt;br&gt;3: Like 1 but skips spatial interlacing check."/>
                 <subopt name="field_dominance" type="int" min="-1" max="1" default="-1" description="(DEPRECATED)&lt;br&gt;-1: auto (default) Only works if the decoder exports the appropriate information and no other filters which discard that information come before tfields in the filter chain, otherwise it falls back to 0 (top field first).&lt;br&gt;0: top field first&lt;br&gt;1: bottom field first&lt;br&gt;NOTE: This option will possibly be removed in a future version. Use −field-dominance instead."/>
             </opt>             
             <opt name="mcdeint" separator=":" description="Motion compensating deinterlacer.&lt;br&gt;It needs one field per frame as input and must thus be used together with tfields=1 or yadif=1/3 or equivalent.">
                 <subopt name="mode" type="int" min="0" max="3" default="0" description="0: fast&lt;br&gt;1: medium&lt;br&gt;2: slow, iterative motion estimation&lt;br&gt;3: extra slow, like 2 plus multiple reference frames"/>
                 <subopt name="parity" type="int" min="0" max="1" default="0" description="0 or 1 selects which field to use (note: no autodetection yet!)."/>
                 <subopt name="qp" type="int" min="0" max="100" default="0" description="Higher values should result in a smoother motion vector field but less optimal individual vectors."/>
             </opt>
             <opt name="boxblur" separator=":" description="box blur">
                 <subopt name="radius" type="float" min="0.1" max="10.0" default="0.1" description="blur filter strength"/>
                 <subopt name="power" type="float" min="0.0" max="100.0" default="0.0" description="number of filter applications"/>
                 <subopt name="radius" type="float" min="0.1" max="10.0" default="0.1" description="blur filter strength"/>
                 <subopt name="power" type="float" min="0.0" max="100.0" default="0.0" description="number of filter applications"/>
             </opt>
             <opt name="sab" separator=":" description="shape adaptive blur">
                 <subopt name="radius" type="float" min="0.1" max="10.0" default="0.1" description="blur filter strength (~0.1−4.0) (slower if larger)"/>
                 <subopt name="pf" type="float" min="0.1" max="10.0" default="0.1" description="prefilter strength (~0.1−2.0)"/>
                 <subopt name="colordiff" type="float" min="0.0" max="100.0" default="0.0" description="maximum difference between pixels to still be considered (~0.1−100.0)"/>
                 <subopt name="radius" type="float" min="0.1" max="10.0" default="0.1" description="blur filter strength (~0.1−4.0) (slower if larger)"/>
                 <subopt name="pf" type="float" min="0.1" max="10.0" default="0.1" description="prefilter strength (~0.1−2.0)"/>
                 <subopt name="colordiff" type="float" min="0.0" max="100.0" default="0.0" description="maximum difference between pixels to still be considered (~0.1−100.0)"/>
             </opt>
             <opt name="smartblur" separator=":" description="smart blur">
                 <subopt name="radius" type="float" min="0.1" max="10.0" default="0.1" description="blur filter strength (~0.1−5.0) (slower if larger)"/>
                 <subopt name="strength" type="float" min="-1.0" max="1.0" default="0.0" description="blur (0.0−1.0) or sharpen (-1.0−0.0)"/>
                 <subopt name="threshold" type="int" min="-30" max="30" default="0" description="filter all (0), filter flat areas (0−30) or filter edges (-30−0)"/>
                 <subopt name="radius" type="float" min="0.1" max="10.0" default="0.1" description="blur filter strength (~0.1−5.0) (slower if larger)"/>
                 <subopt name="strength" type="float" min="-1.0" max="1.0" default="0.0" description="blur (0.0−1.0) or sharpen (-1.0−0.0)"/>
                 <subopt name="threshold" type="int" min="-30" max="30" default="0" description="filter all (0), filter flat areas (0−30) or filter edges (-30−0)"/>
             </opt>
             <opt name="perspective" separator=":" description="Correct the perspective of movies not filmed perpendicular to the screen.">
                 <subopt name="x0" type="int" min="0" max="10000" default="0" description="coordinates of top left"/>
                 <subopt name="y0" type="int" min="0" max="10000" default="0" description="coordinates of top left"/>
                 <subopt name="x1" type="int" min="0" max="10000" default="0" description="coordinates of top right"/>
                 <subopt name="y1" type="int" min="0" max="10000" default="0" description="coordinates of top right"/>
                 <subopt name="x2" type="int" min="0" max="10000" default="0" description="coordinates of bottom left"/>
                 <subopt name="y2" type="int" min="0" max="10000" default="0" description="coordinates of bottom left"/>
                 <subopt name="x3" type="int" min="0" max="10000" default="0" description="coordinates of bottom right"/>
                 <subopt name="x3" type="int" min="0" max="10000" default="0" description="coordinates of bottom right"/>
                 <subopt name="t" type="int" min="0" max="1" default="0" description="inear (0) or cubic resampling (1)"/>
             </opt>
             <opt name="2xsai" type="bool" default="false" description="Scale and smooth the image with the 2x scale and interpolate algorithm."/>
             <opt name="1bpp" type="bool" default="false" description="1bpp bitmap to YUV/BGR 8/15/16/32 conversion"/>
             <opt name="down3dright" separator=":" description="Reposition and resize stereoscopic images.&lt;br&gt;Extracts both stereo fields and places them side by side, resizing them to maintain the original movie aspect.">
                 <subopt name="lines" type="int" min="0" max="100" default="12" description="number of lines to select from the middle of the image (default: 12)"/>
             </opt>
             <opt name="bmovl" separator=":" description="The bitmap overlay filter reads bitmaps from a FIFO and displays them on top of the movie,&lt;br&gt;allowing some transformations on the image. Also see TOOLS/bmovl-test.c for a small bmovl test program.">
                 <subopt name="hidden" type="int" min="0" max="1" default="0" description="Set the default value of the ’hidden’ flag (0=visible, 1=hidden)."/>
                 <subopt name="opaque" type="int" min="0" max="1" default="0" description="Set the default value of the ’opaque’ flag (0=transparent, 1=opaque)."/>
                 <subopt name="fifo" type="string" default="" description="path/filename for the FIFO (named pipe connecting ’mencoder −vf bmovl’ to the controlling application)&lt;br&gt;FIFO commands are:&lt;br&gt;- RGBA32 width height xpos ypos alpha. clear followed by width*height*4 Bytes of raw RGBA32 data.&lt;br&gt;- ABGR32 width height xpos ypos alpha. clear followed by width*height*4 Bytes of raw ABGR32 data.&lt;br&gt;- RGB24 width height xpos ypos alpha clear. followed by width*height*3 Bytes of raw RGB24 data.&lt;br&gt;- BGR24 width height xpos ypos alpha clear. followed by width*height*3 Bytes of raw BGR24 data.&lt;br&gt;- ALPHA width height xpos ypos alpha. Change alpha transparency of the specified area.&lt;br&gt;- CLEAR width height xpos ypos. Clear area.&lt;br&gt;- OPAQUE : Disable all alpha transparency. Send 'ALPHA 0 0 0 0 0' to enable it again.&lt;br&gt;- HIDE : Hide bitmap.&lt;br&gt;- SHOW : Show bitmap.&lt;br&gt;&lt;br&gt;Arguments are:&lt;br&gt;width, height : image/area size&lt;br&gt;xpos, ypos : Start blitting at position x/y.&lt;br&gt;alpha : Set alpha difference. If you set this to -255 you can then send a sequence of ALPHA-commands to set the area to -225, -200, -175 etc for a nice fade-in-effect! ;)&lt;br&gt;...0: same as original&lt;br&gt;...255: Make everything opaque.&lt;br&gt;...-255: Make everything transparent.&lt;br&gt;clear : Clear the framebuffer before blitting.&lt;br&gt;...0: The image will just be blitted on top of the old one, so you do not need to send 1.8MB of RGBA32 data every time a small part of the screen is updated.&lt;br&gt;...1: clear"/>
             </opt>
             <opt name="framestep" separator=":" description="Renders only every nth frame or every intra frame (keyframe).&lt;br&gt;If you call the filter with I (uppercase) as the parameter, then only keyframes are rendered. For DVDs it generally means one in every 15/12 frames (IBBPBBPBBPBBPBB), for AVI it means every scene change or every keyint value (see −lavcopts keyint= value if you use MEncoder to encode the video).&lt;br&gt;When a keyframe is found, an ’I!’ string followed by a newline character is printed, leaving the current line of MPlayer/ MEncoder output on the screen, because it contains the time (in seconds) and frame number of the keyframe (You can use this information to split the AVI.).&lt;br&gt;If you call the filter with a numeric parameter ’step’ then only one in every ’step’ frames is rendered.&lt;br&gt;If you put an ’i’ (lowercase) before the number then an ’I!’ is printed (like the I parameter).&lt;br&gt;If you give only the i then nothing is done to the frames, only I! is printed.">
                 <subopt name="i" type="int" min="1" max="100" default=" " prefix="i" description="" special=" "/>
                 <subopt name="I" type="int" min="1" max="100" default=" " prefix="I" description="" special=" "/>
             </opt>
             <opt name="tile" separator=":" description="Tile a series of images into a single, bigger image.&lt;br&gt;If you omit a parameter or use a value less than 0, then the default value is used. You can also stop when you are satisfied (... −vf tile=10:5 ...). It is probably a good idea to put the scale filter before the tile :-)">
                 <subopt name="xtiles" type="int" min="0" max="100" default="5" description="number of tiles on the x axis (default: 5)"/>
                 <subopt name="ytiles" type="int" min="0" max="100" default="5" description="number of tiles on the y axis (default: 5)"/>
                 <subopt name="output" type="int" min="0" max="100" default="50" description="Render the tile when ’output’ number of frames are reached, where ’output’ should be a number less than xtile * ytile. Missing tiles are left blank. You could, for example, write an 8 * 7 tile every 50 frames to have one image every 2 seconds @ 25 fps."/>
                 <subopt name="start" type="int" min="0" max="100" default="2" description="outer border thickness in pixels (default: 2)"/>
                 <subopt name="delta" type="int" min="0" max="100" default="4" description="inner border thickness in pixels (default: 4)"/>
             </opt>
             <opt name="delogo" separator=":" description="Suppresses a TV station logo by a simple interpolation of the surrounding pixels. Just set a rectangle covering the logo and watch it disappear (and sometimes something even uglier appear − your mileage may vary).">
                 <subopt name="x" type="int" min="0" max="1000" default="0" description="left corner of the logo"/>
                 <subopt name="y" type="int" min="0" max="1000" default="0" description="top corner of the logo"/>
                 <subopt name="w" type="int" min="0" max="1000" default="0" description="width of the cleared rectangle"/>
                 <subopt name="h" type="int" min="0" max="1000" default="0" description="height of the cleared rectangle"/>
                 <subopt name="t" type="int" min="0" max="1000" default="0" description="Thickness of the fuzzy edge of the rectangle (added to w and h).&lt;br&gt; When set to -1, a green rectangle is drawn on the screen to simplify finding the right x,y,w,h parameters."/>
             </opt>
             <opt name="remove-logo" type="string" default="" description="Suppresses a TV station logo, using a PGM or PPM image file to determine which pixels comprise the logo. The width and height of the image file must match those of the video stream being processed. Uses the filter image and a circular blur algorithm to remove the logo.&lt;br&gt;/path/to/logo_bitmap_file_name.pgm : [path] + filename of the filter image."/>
        </vf>
        <af separator=",">
            <opt name="resample" separator=":" description="Changes the sample rate of the audio stream. Can be used if you have a fixed frequency sound card or if you are stuck with an old sound card that is only capable of max 44.1kHz. This filter is automatically enabled if necessary. It only supports 16-bit integer and float in native-endian format as input.&lt;br&gt;NOTE: With MEncoder, you need to also use −srate srate.">
                    <subopt name="srate" type="int" min="8000" max="192000" default="44100" description="output sample frequency in Hz. The valid range for this parameter is 8000 to 192000.&lt;br&gt;If the input and output sample frequency are the same or if this parameter is omitted the filter is automatically unloaded. A high sample frequency normally improves the audio quality, especially when used in combination with other filters."/>
                    <subopt name="sloppy" type="int" min="0" max="1" default="0" description="Allow (1) or disallow (0) the output frequency to differ slightly from the frequency given by srate (default: 1).&lt;br&gt;Can be used if the startup of the playback is extremely slow."/>
                    <subopt name="type" type="int" min="0" max="2" default="0" description="Selects which resampling method to use.&lt;br&gt;0: linear interpolation (fast, poor quality especially when upsampling)&lt;br&gt;1: polyphase filterbank and integer processing&lt;br&gt;2: polyphase filterbank and floating point processing (slow, best quality)"/>
            </opt>
            <opt name="lavcresample" separator=":" description="Changes the sample rate of the audio stream to an integer srate in Hz. It only supports the 16-bit native-endian format.&lt;br&gt;NOTE: With MEncoder, you need to also use −srate srate.">
                <subopt name="srate" type="int" min="8000" max="192000" default="44100" description="the output sample rate"/>
                <subtop name="length" type="int" min="0" max="100" default="16" description="length of the filter with respect to the lower sampling rate (default: 16)"/>
                <subopt name="linear" type="int" min="0" max="1" default="0" description="if 1 then filters will be linearly interpolated between polyphase entries"/>
                <subopt name="count" type="int" min="0" max="100" default="10" description="log2 of the number of polyphase entries (..., 10->1024, 11->2048, 12->4096, ...) (default: 10->1024)"/>
                <subopt name="cutoff" type="float" min="0.0" max="1.0" default="0.0" description="cutoff frequency (0.0-1.0), default set depending upon filter length"/>               
            </opt>
            <opt name="sweep" type="float" min="0.0" max="1.0" default="0.0" description="Produces a sine sweep.&lt;br&gt;0.0−1.0 : Sine function delta, use very low values to hear the sweep."/>
            <opt name="sinesuppress" separator=":" description="Remove a sine at the specified frequency. Useful to get rid of the 50/60Hz noise on low quality audio equipment. It probably only works on mono input.">
                <subopt name="freq" type="int" min="0" max="100" default="50" description="The frequency of the sine which should be removed (in Hz) (default: 50)"/>
                <subopt name="decay" type="float" min="0.0" max="1.0"  default="0.0001" step="0.0001" precision="4" description="Controls the adaptivity (a larger value will make the filter adapt to amplitude and phase changes quicker, a smaller value will make the adaptation slower) (default: 0.0001).&lt;br&gt; Reasonable values are around 0.001."/>
            </opt>
            <opt name="hrtf" type="string" default="0" description="Head-related transfer function: Converts multichannel audio to 2 channel output for headphones, preserving the spatiality of the sound.&lt;br&gt;Flag Meaning&lt;br&gt;- m : matrix decoding of the rear channel&lt;br&gt;- s : 2-channel matrix decoding&lt;br&gt;- 0 : no matrix decoding (default)">
                <value name="m"/>
                <value name="s"/>
                <value name="0"/>
            </opt>
            <opt name="equalizer" separator=":" description="10 octave band graphic equalizer, implemented using 10 IIR band pass filters. This means that it works regardless of what type of audio is being played back. The center frequencies for the 10 bands are:&lt;br&gt;No. frequency&lt;br&gt;0 31.25 Hz&lt;br&gt;1 62.50 Hz&lt;br&gt;2 125.00 Hz&lt;br&gt;3 250.00 Hz&lt;br&gt;4 500.00 Hz&lt;br&gt;5 1.00 kHz&lt;br&gt;6 2.00 kHz&lt;br&gt;7 4.00 kHz&lt;br&gt;8 8.00 kHz&lt;br&gt;9 16.00 kHz&lt;br&gt;&lt;br&gt;If the sample rate of the sound being played is lower than the center frequency for a frequency band, then that band will be disabled. A known bug with this filter is that the characteristics for the uppermost band are not completely symmetric if the sample rate is close to the center frequency of that band. This problem can be worked around by upsampling the sound using the resample filter before it reaches this filter."> 
                <subopt name="g1" type="float" min="-12.0" max="12.0" default="0.0" description="floating point numbers representing the gain in dB for each frequency band (-12−12)"/>
                <subopt name="g2" type="float" min="-12.0" max="12.0" default="0.0" description="floating point numbers representing the gain in dB for each frequency band (-12−12)"/>
                <subopt name="g3" type="float" min="-12.0" max="12.0" default="0.0" description="floating point numbers representing the gain in dB for each frequency band (-12−12)"/>
                <subopt name="g4" type="float" min="-12.0" max="12.0" default="0.0" description="floating point numbers representing the gain in dB for each frequency band (-12−12)"/>
                <subopt name="g5" type="float" min="-12.0" max="12.0" default="0.0" description="floating point numbers representing the gain in dB for each frequency band (-12−12)"/>
                <subopt name="g6" type="float" min="-12.0" max="12.0" default="0.0" description="floating point numbers representing the gain in dB for each frequency band (-12−12)"/>
                <subopt name="g7" type="float" min="-12.0" max="12.0" default="0.0" description="floating point numbers representing the gain in dB for each frequency band (-12−12)"/>
                <subopt name="g8" type="float" min="-12.0" max="12.0" default="0.0" description="floating point numbers representing the gain in dB for each frequency band (-12−12)"/>
                <subopt name="g9" type="float" min="-12.0" max="12.0" default="0.0" description="floating point numbers representing the gain in dB for each frequency band (-12−12)"/>
                <subopt name="g10" type="float" min="-12.0" max="12.0" default="0.0" description="floating point numbers representing the gain in dB for each frequency band (-12−12)"/>
            </opt>
            <opt name="channels" type="string" default="" description="&lt;b&gt;channels=nch[:nr:from1:to1:from2:to2:from3:to3:...]&lt;/b&gt;&lt;br&gt;Can be used for adding, removing, routing and copying audio channels. If only nch is given the default routing is used, it works as follows: If the number of output channels is bigger than the number of input channels empty channels are inserted (except mixing from mono to stereo, then the mono channel is repeated in both of the output channels). If the number of output channels is smaller than the number of input channels the exceeding channels are truncated.&lt;br&gt;nch : number of output channels (1−6)&lt;br&gt;nr : number of routes (1−6)&lt;br&gt;from1:to1:from2:to2:from3:to3:...: Pairs of numbers between 0 and 5 that define where to route each channel."/>
            <opt name="format" type="string" default="" description="Convert between different sample formats. Automatically enabled when needed by the sound card or another filter.&lt;br&gt;format : Sets the desired format. The general form is ’sbe’, where ’s’ denotes the sign (either ’s’ for signed or ’u’ for unsigned), ’b’ denotes the number of bits per sample (16, 24 or 32) and ’e’ denotes the endianness (’le’ means little-endian, ’be’ big-endian and ’ne’ the endianness of the computer MPlayer is running on). Valid values (amongst others) are: ’s16le’, ’u32be’ and ’u24ne’. Exceptions to this rule that are also valid format specifiers: u8, s8, floatle, floatbe, floatne, mulaw, alaw, mpeg2, ac3 and imaadpcm."/>
            <opt name="volume" separator=":" description="Implements software volume control. Use this filter with caution since it can reduce the signal to noise ratio of the sound. In most cases it is best to set the level for the PCM sound to max, leave this filter out and control the output level to your speakers with the master volume control of the mixer. In case your sound card has a digital PCM mixer instead of an analog one, and you hear distortion, use the MASTER mixer instead. If there is an external amplifier connected to the computer (this is almost always the case), the noise level can be minimized by adjusting the master level and the volume knob on the amplifier until the hissing noise in the background is gone.&lt;br&gt;This filter has a second feature: It measures the overall maximum sound level and prints out that level when MPlayer exits. This volume estimate can be used for setting the sound level in MEncoder such that the maximum dynamic range is utilized.&lt;br&gt;NOTE: This filter is not reentrant and can therefore only be enabled once for every audio stream."> 
                <subopt name="v" type="int" min="-200" max="60" default="0" description="Sets the desired gain in dB for all channels in the stream from -200dB to +60dB,&lt;br&gt;where -200dB mutes the sound completely and +60dB equals a gain of 1000 (default: 0)."/>
                <subopt name="sc" type="int" min="0" max="1" default="0" description="Turns soft clipping on (1) or off (0). Soft-clipping can make the sound more smooth if very high volume levels are used. Enable this option if the dynamic range of the loudspeakers is very low.&lt;br&gt;WARNING: This feature creates distortion and should be considered a last resort."/>
            </opt>
            <opt name="pan" type="string" default="" description="Mixes channels arbitrarily. Basically a combination of the volume and the channels filter that can be used to down-mix many channels to only a few, e.g. stereo to mono or vary the 'width' of the center speaker in a surround sound system. This filter is hard to use, and will require some tinkering before the desired result is obtained. The number of options for this filter depends on the number of output channels. An example how to downmix a six-channel file to two channels with this filter can be found in the examples section near the end.&lt;br&gt;&lt;br&gt;n : number of output channels (1−6)&lt;br&gt;Lij : How much of input channel i is mixed into output channel j (0−1). So in principle you first have n numbers saying what to do with the first input channel, then n numbers that act on the second input channel etc. If you do not specify any numbers for some input channels, 0 is assumed.&lt;br&gt;&lt;br&gt;EXAMPLE:&lt;br&gt;mplayer −af pan=1:0.5:0.5 media.avi&lt;br&gt;Would down-mix from stereo to mono.&lt;br&gt;mplayer −af pan=3:1:0:0.5:0:1:0.5 media.avi&lt;br&gt;Would give 3 channel output leaving channels 0 and 1 intact, and mix channels 0 and 1 into output channel 2 (which could be sent to a subwoofer for example)."/>
            <opt name="sub" separator=":" description="Adds a subwoofer channel to the audio stream. The audio data used for creating the subwoofer channel is an average of the sound in channel 0 and channel 1. The resulting sound is then low-pass filtered by a 4th order Butterworth filter with a default cutoff frequency of 60Hz and added to a separate channel in the audio stream.&lt;br&gt;Warning: Disable this filter when you are playing DVDs with Dolby Digital 5.1 sound, otherwise this filter will disrupt the sound to the subwoofer.">
                <subopt name="fc" type="int" min="20" max="300" default="60" description="cutoff frequency in Hz for the low-pass filter (20Hz to 300Hz) (default: 60Hz)&lt;br&gt;For the best result try setting the cutoff frequency as low as possible. This will improve the stereo or surround sound experience."/>
                <subopt name="ch" type="int" min="0" max="5" default="5" description="Determines the channel number in which to insert the sub-channel audio. Channel number can be between 0 and 5 (default: 5).&lt;br&gt;Observe that the number of channels will automatically be increased to ch if necessary."/>
            </opt>
            <opt name="center" type="int" min="0" max="5" default="5" description="Creates a center channel from the front channels. May currently be low quality as it does not implement a high-pass filter for proper extraction yet, but averages and halves the channels instead.&lt;br&gt;&lt;br&gt;ch : Determines the channel number in which to insert the center channel. Channel number can be between 0 and 5 (default: 5). Observe that the number of channels will automatically be increased to ch if necessary."/>
            <opt name="surround" type="int" min="0" max="1000" default="20" description="Decoder for matrix encoded surround sound like Dolby Surround. Many files with 2 channel audio actually contain matrixed surround sound. Requires a sound card supporting at least 4 channels.&lt;br&gt;&lt;br&gt;delay : delay time in ms for the rear speakers (0 to 1000) (default: 20) This delay should be set as follows: If d1 is the distance from the listening position to the front speakers and d2 is the distance from the listening position to the rear speakers, then the delay should be set to 15ms if d1 lt or = d2 and to 15 + 5*(d1-d2) if d1 > d2."/>
            <opt name="delay" separator=":" description="Delays the sound to the loudspeakers such that the sound from the different channels arrives at the listening position simultaneously. It is only useful if you have more than 2 loudspeakers.&lt;br&gt;- 1.Measure the distance to the loudspeakers in meters in relation to your listening position, giving you the distances s1 to s5 (for a 5.1 system). There is no point in compensating for the subwoofer (you will not hear the difference anyway).&lt;br&gt;- 2. Subtract the distances s1 to s5 from the maximum distance, i.e. s[i] = max(s) - s[i]; i = 1...5.&lt;br&gt;- 3. Calculate the required delays in ms as d[i] = 1000*s[i]/342; i = 1...5.">
                <subopt name="ch0" type="float" min="0" max="1000" default="0.0" description="the delay in ms that should be imposed on each channel (floating point number between 0 and 1000)."/>
                <subopt name="ch1" type="float" min="0" max="1000" default="0.0" description="the delay in ms that should be imposed on each channel (floating point number between 0 and 1000)."/>
                <subopt name="ch2" type="float" min="0" max="1000" default="0.0" description="the delay in ms that should be imposed on each channel (floating point number between 0 and 1000)."/>
                <subopt name="ch3" type="float" min="0" max="1000" default="0.0" description="the delay in ms that should be imposed on each channel (floating point number between 0 and 1000)."/>
                <subopt name="ch4" type="float" min="0" max="1000" default="0.0" description="the delay in ms that should be imposed on each channel (floating point number between 0 and 1000)."/>
                <subopt name="ch5" type="float" min="0" max="1000" default="0.0" description="the delay in ms that should be imposed on each channel (floating point number between 0 and 1000)."/>
            </opt>
            <opt name="extrastereo" type="float" min="-10.0" max="10.0" default="2.5" description="(Linearly) increases the difference between left and right channels which adds some sort of 'live' effect to playback.&lt;br&gt;&lt;br&gt;mul : Sets the difference coefficient (default: 2.5). 0.0 means mono sound (average of both channels), with 1.0 sound will be unchanged, with -1.0 left and right channels will be swapped."/>
            <opt name="volnorm" separator=":" description="Maximizes the volume without distorting the sound.">
                <subopt name="method" type="int" min="1" max="2" default="1" description="Sets the used method.&lt;br&gt;1: Use a single sample to smooth the variations via the standard weighted mean over past samples (default).&lt;br&gt;2: Use several samples to smooth the variations via the standard weighted mean over past samples."/>
                <subopt name="target" type="float" min="0.0" max="10.0" default="0.25" description="Sets the target amplitude as a fraction of the maximum for the sample type (default: 0.25)."/>
            </opt>
            <opt name="comp" type="bool" default="false" description="Compressor/expander filter usable for microphone input.&lt;br&gt;Prevents artifacts on very loud sound and raises the volume on very low sound. This filter is untested, maybe even unusable."/>
            <opt name="gate" type="bool" default="false" description="Noise gate filter similar to the comp audio filter.&lt;br&gt;This filter is untested, maybe even unusable."/>
            <opt name="karaoke" type="bool" default="false" description="Simple voice removal filter exploiting the fact that voice is usually recorded with mono gear and later ’center’ mixed onto the final audio stream.&lt;br&gt;Beware that this filter will turn your signal into mono. Works well for 2 channel tracks; do not bother trying it on anything but 2 channel stereo."/>
        </af>
    </FILTERS>
    <AUDIO>
        <lavc options="lavcopts">
            <opt type="string" name="acodec" default="mp3">
                <value name="mp3"/>
                <value name="mp2"/>
                <value name="ac3"/>
                <value name="adpcm_ima_wav"/>
                <value name="sonic"/>
            </opt>
            <opt type="int" name="abitrate" min="1" max="1000" default="$AUDBR" special="$AUDBR"/>
        </lavc>
        <toolame options="toolameopts">
            <opt type="int" name="br" min="0" max="384" default="$AUDBR" special="$AUDBR"/>
            <opt type="int" name="vbr" min="-50" max="50" default="0" />
            <opt type="int" name="maxvbr" min="32" max="384" default="384"/>
            <opt type="string" name="mode" default="stereo">
                <value name="stereo"/>
                <value name="jstereo"/>
                <value name="mono"/>
                <value name="dual"/>
            </opt>
            <opt type="int" name="psy" min="1" max="4"/>
            <opt type="int" name="errprot" min="0" max="1" default="0" />
        </toolame>
        <faac options="faacopts">
            <opt type="int" name="br" min="1" max="1000" default="$AUDBR" special="$AUDBR" description="average bitrate in kbps (mutually exclusive with quality)"/>
            <opt type="int" name="quality" min="1" max="1000" default="500" description="quality mode, the higher the better (mutually exclusive with br)"/>
            <opt type="int" name="object" min="1" max="4" default="1" description="object type complexity&lt;br&gt;1:MAIN&lt;br&gt;2:LOW&lt;br&gt;3:SSR&lt;br&gt;4:LTP (extremely slow)"/>
            <opt type="string" name="mpeg"  default="4">
                <value name="2"/>
                <value name="4"/>
            </opt>
            <opt type="bool" name="tns" default="true" description="Enables temporal noise shaping."/>
            <opt type="int" name="cutoff" min="0" max="24000" default="22050" description="cutoff frequency (default: sampling_rate/2)"/>
            <opt type="bool" name="raw" default="false" description="Stores the bitstream as raw payload with extradata in the container header (default: 0, corresponds to ADTS).&lt;br&gt;Do not set this flag if not explicitly required or you will not be able to remux the audio stream later on."/>
        </faac>
    </AUDIO>
    
    <VIDEO>
        <xvid options="xvidencopts">
            <opt type="int" name="pass" min="1" max="2" default="$PASS" special="$PASS" description="Specify the pass in two pass mode."/>
            <opt type="bool" name="turbo" default="false" description="Dramatically speeds up pass one using faster algorithms and disabling CPU-intensive options.&lt;br&gt; This will probably reduce global PSNR a little bit and change individual frame type and PSNR a little bit more." />
            <opt type="int" name="bitrate" default="$VIDBR" min="0" max="16000" special="$VIDBR" description="Sets the bitrate to be used in kbits/second. &lt;br&gt;(default: 687 kbits/s)." />
            <opt type="int" name="fixed_quant" default="1" min="1" max="31" description="Switch to fixed quantizer mode and specify the quantizer to be used."/>
            <opt type="int" name="me_quality" default="6" min="0" max="6" description="This option controls the motion estimation subsystem. The higher the value, the more precise the estimation should be (default: 6)&lt;br&gt; The more precise the motion estimation is, the more bits can be saved. Precision is gained at the expense of CPU time so decrease this setting if you need realtime encoding."/>
            <opt type="bool" name="qpel" default="false" description="MPEG-4 uses a half pixel precision for its motion search by default. The standard proposes a mode where encoders are allowed to use quarter pixel precision.&lt;br&gt;This option usually results in a sharper image. Unfortunately it has a great impact on bitrate and sometimes the higher bitrate use will prevent it from giving a better image quality at a fixed bitrate. It is better to test with and without this option and see whether it is worth activating."/>
            <opt type="bool" name="noqpel" default="false" description="MPEG-4 uses a half pixel precision for its motion search by default. The standard proposes a mode where encoders are allowed to use quarter pixel precision.&lt;br&gt;This option usually results in a sharper image. Unfortunately it has a great impact on bitrate and sometimes the higher bitrate use will prevent it from giving a better image quality at a fixed bitrate. It is better to test with and without this option and see whether it is worth activating."/>
            <opt type="bool" name="gmc" default="false" description="Enable Global Motion Compensation, which makes Xvid generate special frames (GMC-frames) which are well suited for Pan/Zoom/ Rotating images.&lt;br&gt; Whether or not the use of this option will save bits is highly dependent on the source material."/>
            <opt type="bool" name="nogmc" default="false" description="Enable Global Motion Compensation, which makes Xvid generate special frames (GMC-frames) which are well suited for Pan/Zoom/ Rotating images.&lt;br&gt; Whether or not the use of this option will save bits is highly dependent on the source material."/>
            <opt type="bool" name="trellis" default="false" description="Trellis Quantization is a kind of adaptive quantization method that saves bits by modifying quantized coefficients to make them more compressible by the entropy encoder.&lt;br&gt;Its impact on quality is good, and if VHQ uses too much CPU for you, this setting can be a good alternative to save a few bits (and gain quality at fixed bitrate) at a lesser cost than with VHQ (default: on)."/>
            <opt type="bool" name="notrellis" default="false" description="Trellis Quantization is a kind of adaptive quantization method that saves bits by modifying quantized coefficients to make them more compressible by the entropy encoder.&lt;br&gt;Its impact on quality is good, and if VHQ uses too much CPU for you, this setting can be a good alternative to save a few bits (and gain quality at fixed bitrate) at a lesser cost than with VHQ (default: on)."/>
            <opt type="bool" name="cartoon" default="false" description="Activate this if your encoded sequence is an anime/cartoon.&lt;br&gt;It modifies some Xvid internal thresholds so Xvid takes better decisions on frame types and motion vectors for flat looking cartoons."/>
            <opt type="bool" name="nocartoon" default="false" description="Activate this if your encoded sequence is an anime/cartoon.&lt;br&gt;It modifies some Xvid internal thresholds so Xvid takes better decisions on frame types and motion vectors for flat looking cartoons."/>
            <opt type="bool" name="chroma_me" default="false" description="The usual motion estimation algorithm uses only the luminance information to find the best motion vector.&lt;br&gt; However for some video material, using the chroma planes can help find better vectors. This setting toggles the use of chroma planes for motion estimation (default: on)."/>
            <opt type="bool" name="nochroma_me" default="false" description="The usual motion estimation algorithm uses only the luminance information to find the best motion vector.&lt;br&gt; However for some video material, using the chroma planes can help find better vectors. This setting toggles the use of chroma planes for motion estimation (default: on)."/>
            <opt type="bool" name="chroma_opt" default="false" description="Enable a chroma optimizer prefilter. It will do some extra magic on color information to minimize the stepped-stairs effect on edges.&lt;br&gt; It will improve quality at the cost of encoding speed. It reduces PSNR by nature, as the mathematical deviation to the original picture will get bigger, but the subjective image quality will raise. Since it works with color information, you might want to turn it off when encoding in grayscale."/>
            <opt type="bool" name="nochroma_opt" default="false" description="Enable a chroma optimizer prefilter. It will do some extra magic on color information to minimize the stepped-stairs effect on edges.&lt;br&gt; It will improve quality at the cost of encoding speed. It reduces PSNR by nature, as the mathematical deviation to the original picture will get bigger, but the subjective image quality will raise. Since it works with color information, you might want to turn it off when encoding in grayscale."/>
            <opt type="bool" name="hq_ac" default="false" description="Activates high-quality prediction of AC coefficients&lt;br&gt;for intra frames from neighbor blocks (default: on)."/>
            <opt type="bool" name="nohq_ac" default="false" description="Activates high-quality prediction of AC coefficients&lt;br&gt;for intra frames from neighbor blocks (default: on)."/>
            <opt type="int" name="vhq" default="1" min="0" max="4" description="The motion search algorithm is based on a search in the usual color domain and tries to find a motion vector that minimizes the difference between the reference frame and the encoded frame.&lt;br&gt; With this setting activated, Xvid will also use the frequency domain (DCT) to search for a motion vector that minimizes not only the spatial difference but also the encoding length of the block. Fastest to slowest:&lt;br&gt;0 : off&lt;br&gt;1 : mode decision (inter/intra MB) (default)&lt;br&gt;2 : limited search&lt;br&gt;3 : medium search&lt;br&gt;4 : wide search"/>
            <opt type="bool" name="lumi_mask" default="false" description="Adaptive quantization allows the macroblock quantizers to vary inside each frame.&lt;br&gt; This is a ’psychosensory’ setting that is supposed to make use of the fact that the human eye tends to notice fewer details in very bright and very dark parts of the picture. It compresses those areas more strongly than medium ones, which will save bits that can be spent again on other frames, raising overall subjective quality and possibly reducing PSNR."/>
            <opt type="bool" name="nolumi_mask" default="false" description="Adaptive quantization allows the macroblock quantizers to vary inside each frame.&lt;br&gt; This is a ’psychosensory’ setting that is supposed to make use of the fact that the human eye tends to notice fewer details in very bright and very dark parts of the picture. It compresses those areas more strongly than medium ones, which will save bits that can be spent again on other frames, raising overall subjective quality and possibly reducing PSNR."/>
            <opt type="bool" name="grayscale" default="false" description="Make Xvid discard chroma planes so the encoded video is grayscale only.&lt;br&gt;Note that this does not speed up encoding, it just prevents chroma data from being written in the last stage of encoding."/>
            <opt type="bool" name="nograyscale" default="false" description="Make Xvid discard chroma planes so the encoded video is grayscale only.&lt;br&gt;Note that this does not speed up encoding, it just prevents chroma data from being written in the last stage of encoding."/>
            <opt type="bool" name="interlacing" default="false" description="Encode the fields of interlaced video material. Turn this option on for interlaced content.&lt;br&gt;NOTE: Should you rescale the video, you would need an interlace-aware resizer, which you can activate with −vf scale=width:height:1."/>
            <opt type="bool" name="nointerlacing" default="false" description="Encode the fields of interlaced video material. Turn this option on for interlaced content.&lt;br&gt;NOTE: Should you rescale the video, you would need an interlace-aware resizer, which you can activate with −vf scale=width:height:1."/>
            <opt type="int" name="min_iquant" default="2" min="0" max="31" description="minimum I-frame quantizer (default: 2)"/>
            <opt type="int" name="max_iquant" default="31" min="0" max="31" description="maximum I-frame quantizer (default: 31)"/>
            <opt type="int" name="min_bquant" default="2" min="0" max="31" description="minimum B-frame quantizer (default: 2)"/>
            <opt type="int" name="max_bquant" default="31" min="0" max="31" description="maximum B-frame quantizer (default: 31)"/>
            <opt type="int" name="min_pquant" default="2" min="0" max="31" description="minimum P-frame quantizer (default: 2)"/>
            <opt type="int" name="max_pquant" default="31" min="0" max="31" description="maximum P-frame quantizer (default: 31)"/>
            <opt type="int" name="min_key_interval" default="0" min="0" max="400" description=" (two pass only)&lt;br&gt;minimum interval between keyframes (default: 0)"/>
            <opt type="int" name="max_key_interval" default="0" min="0" max="400" description="maximum interval between keyframes (default: 10*fps)"/>
            <opt type="string" name="quant_type" default="mpeg" description="Sets the type of quantizer to use.&lt;br&gt;For high bitrates, you will find that MPEG quantization preserves more detail. For low bitrates, the smoothing of H.263 will give you less block noise. When using custom matrices, MPEG quantization must be used.">
                <value name="h263"/>
                <value name="mpeg"/>
            </opt>
            <opt type="int" name="keyframe_boost" default="0" min="0" max="1000" description="Shift some bits from the pool for other frame types to intra frames, thus improving keyframe quality.&lt;br&gt;This amount is an extra percentage, so a value of 10 will give your keyframes 10% more bits than normal (default: 0).&lt;br&gt;(two pass mode only)"/>
            <opt type="int" name="kfthreshold" default="10" min="0" max="100" description="Works together with kfreduction. Determines the minimum distance below which you consider that two frames are considered consecutive and treated differently according to kfreduction (default: 10).&lt;br&gt;(two pass mode only)"/>
            <opt type="int" name="kfreduction" default="30" min="0" max="100" description="The above two settings can be used to adjust the size of keyframes that you consider too close to the first (in a row). kfthreshold sets the range in which keyframes are reduced, and kfreduction determines the bitrate reduction they get. The last I-frame will get treated normally (default: 30)&lt;br&gt;(two pass mode only)"/>
            <opt type="int" name="max_bframes" min="0" max="4" default="2" description="Maximum number of B-frames to put between I/P-frames (default: 2)."/> 
            <opt type="int" name="bquant_ratio" min="0" max="1000" default="150" description="quantizer ratio between B- and non-B-frames, 150=1.50 (default: 150)"/>
            <opt type="int" name="bquant_offset" min="-1000" max="1000" default="100" description="quantizer offset between B- and non-B-frames, 100=1.00 (default: 100)"/>
            <opt type="int" name="bf_threshold" min="-255" max="255" default="0" description="This setting allows you to specify what priority to place on the use of B-frames.&lt;br&gt;The higher the value, the higher the probability of B-frames being used (default: 0). Do not forget that B-frames usually have a higher quantizer, and therefore aggressive production of B-frames may cause worse visual quality."/>
            <opt type="bool" name="closed_gop" default="true" description="This option tells Xvid to close every GOP (Group Of Pictures bounded by two I-frames), which makes GOPs independent from each other.&lt;br&gt;This just implies that the last frame of the GOP is either a P-frame or a N-frame but not a B-frame. It is usually a good idea to turn this option on (default: on)"/>
            <opt type="bool" name="noclosed_gop" default="true" description="This option tells Xvid to close every GOP (Group Of Pictures bounded by two I-frames), which makes GOPs independent from each other.&lt;br&gt;This just implies that the last frame of the GOP is either a P-frame or a N-frame but not a B-frame. It is usually a good idea to turn this option on (default: on)"/>
            <opt type="bool" name="packed" default="true" description="This option is meant to solve frame-order issues when encoding to container formats like AVI that cannot cope with out-of-order frames.&lt;br&gt;In practice, most decoders (both software and hardware) are able to deal with frame-order themselves, and may get confused when this option is turned on, so you can safely leave if off, unless you really know what you are doing.&lt;br&gt;WARNING: This will generate an illegal bitstream, and will not be decodable by ISO-MPEG-4 decoders except DivX/libavcodec/ Xvid.&lt;br&gt;WARNING: This will also store a fake DivX version in the file so the bug autodetection of some decoders might be confused."/>
            <opt type="bool" name="nopacked" default="true" description="This option is meant to solve frame-order issues when encoding to container formats like AVI that cannot cope with out-of-order frames.&lt;br&gt;In practice, most decoders (both software and hardware) are able to deal with frame-order themselves, and may get confused when this option is turned on, so you can safely leave if off, unless you really know what you are doing.&lt;br&gt;WARNING: This will generate an illegal bitstream, and will not be decodable by ISO-MPEG-4 decoders except DivX/libavcodec/ Xvid.&lt;br&gt;WARNING: This will also store a fake DivX version in the file so the bug autodetection of some decoders might be confused."/>
            <opt type="int" name="frame_drop_ratio" default="0" min="0" max="100" description="This setting allows the creation of variable framerate video streams. The value of the setting specifies a threshold under which, if the difference of the following frame to the previous frame is below or equal to this threshold, a frame gets not coded (a so called n-vop is placed in the stream). On playback, when reaching an n-vop the previous frame will be displayed.&lt;br&gt;WARNING: Playing with this setting may result in a jerky video, so use it at your own risks!"/>
            <opt type="int" name="rc_reacting_delay_factor" min="0" max="1000" default="0" description="This parameter controls the number of frames the CBR rate controller will wait before reacting to bitrate changes&lt;br&gt;and compensating for them to obtain a constant bitrate over an averaging range of frames."/>
            <opt type="int" name="rc_averaging_period" min="0" max="1000" default="0" description="Real CBR is hard to achieve. Depending on the video material, bitrate can be variable, and hard to predict.&lt;br&gt;Therefore Xvid uses an averaging period for which it guarantees a given amount of bits (minus a small variation). This settings expresses the 'number of frames' for which Xvid averages bitrate and tries to achieve CBR."/>
            <opt type="int" name="rc_buffer" min="0" max="10000" default="0" description="size of the rate control buffer"/>
            <opt type="int" name="curve_compression_high" min="0" max="100" default="0" description="This setting allows Xvid to take a certain percentage of bits away from high bitrate scenes and give them back to the bit reservoir.&lt;br&gt;You could also use this if you have a clip with so many bits allocated to high-bitrate scenes that the low(er)-bitrate scenes start to look bad (default: 0)"/>
            <opt type="int" name="curve_compression_low" min="0" max="100" default="0" description="This setting allows Xvid to give a certain percentage of extra bits to the low bitrate scenes, taking a few bits from the entire clip.&lt;br&gt;This might come in handy if you have a few low-bitrate scenes that are still blocky (default: 0)."/>
            <opt type="int" name="overflow_control_strength" min="0" max="100" default="5" description="During pass one of two pass encoding, a scaled bitrate curve is computed. The difference between that expected curve and the result obtained during encoding is called overflow. Obviously, the two pass rate controller tries to compensate for that overflow, distributing it over the next frames. This setting controls how much of the overflow is distributed every time there is a new frame. Low values allow lazy overflow control, big rate bursts are compensated for more slowly (could lead to lack of precision for small clips). Higher values will make changes in bit redistribution more abrupt, possibly too abrupt if you set it too high, creating artifacts (default: 5).&lt;br&gt;NOTE: This setting impacts quality a lot, play with it carefully!"/>
            <opt type="int" name="max_overflow_improvement" min="0" max="100" default="5" description="During the frame bit allocation, overflow control may increase the frame size.&lt;br&gt;This parameter specifies the maximum percentage by which the overflow control is allowed to increase the frame size, compared to the ideal curve allocation (default: 5)."/>
            <opt type="int" name="max_overflow_degradation" min="0" max="100" default="5" description="During the frame bit allocation, overflow control may decrease the frame size.&lt;br&gt;This parameter specifies the maximum percentage by which the overflow control is allowed to decrease the frame size, compared to the ideal curve allocation (default: 5)."/>
            <opt type="int" name="container_frame_overhead" min="0" max="1000" default="0" description="Specifies a frame average overhead per frame, in bytes. Most of the time users express their target bitrate for video w/o taking care of the video container overhead.&lt;br&gt;This small but (mostly) constant overhead can cause the target file size to be exceeded. Xvid allows users to set the amount of overhead per frame the container generates (give only an average per frame). 0 has a special meaning, it lets Xvid use its own default values (default: 24 − AVI average overhead)."/>
            <opt type="string" name="profile" default="unrestricted" description="Restricts options and VBV (peak bitrate over a short period) according to the Simple, Advanced Simple and DivX profiles. The resulting videos should be playable on standalone players adhering to these profile specifications.&lt;br&gt;- unrestricted : no restrictions (default)&lt;br&gt;- sp0 : simple profile at level 0&lt;br&gt;- sp1 : simple profile at level 1&lt;br&gt;- sp2 : simple profile at level 2&lt;br&gt;- sp3 : simple profile at level 3&lt;br&gt;- asp0 : advanced simple profile at level 0&lt;br&gt;- asp1 : advanced simple profile at level 1&lt;br&gt;- asp2 : advanced simple profile at level 2&lt;br&gt;- asp3 : advanced simple profile at level 3&lt;br&gt;- asp4 : advanced simple profile at level 4&lt;br&gt;- asp5 : advanced simple profile at level 5&lt;br&gt;- dxnhandheld : DXN handheld profile&lt;br&gt;- dxnportntsc : DXN portable NTSC profile&lt;br&gt;- dxnportpal : DXN portable PAL profile&lt;br&gt;- dxnhtntsc : DXN home theater NTSC profile&lt;br&gt;- dxnhtpal : DXN home theater PAL profile&lt;br&gt;- dxnhdtv : DXN HDTV profile&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: These profiles should be used in conjunction with an appropriate −ffourcc. Generally DX50 is applicable, as some players do not recognize Xvid but most recognize DivX.">
                <value name="unrestricted"/>
                <value name="sp0"/>
                <value name="sp3"/>
                <value name="asp0"/>
                <value name="asp1"/>
                <value name="asp2"/>
                <value name="asp3"/>
                <value name="asp4"/>
                <value name="asp5"/>
                <value name="dxnhandheld"/>
                <value name="dxnportntsc"/>
                <value name="dxnhtntsc"/>
                <value name="dxnhtpal"/>
                <value name="dxnhdtv"/>
            </opt>
            <opt type="string" name="par" default="vga11" description="Specifies the Pixel Aspect Ratio mode (not to be confused with DAR, the Display Aspect Ratio). PAR is the ratio of the width and height of a single pixel. So both are related like this: DAR = PAR * (width/height).&lt;br&gt;MPEG-4 defines 5 pixel aspect ratios and one extended one, giving the opportunity to specify a specific pixel aspect ratio. 5 standard modes can be specified:&lt;br&gt;- vga11 : It is the usual PAR for PC content. Pixels are a square unit.&lt;br&gt;- pal43 : PAL standard 4:3 PAR. Pixels are rectangles.&lt;br&gt;- pal169 : same as above&lt;br&gt;- ntsc43 : same as above&lt;br&gt;- ntsc169 : same as above (Do not forget to give the exact ratio.)&lt;br&gt;- ext :Allows you to specify your own pixel aspect ratio with par_width and par_height.&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: In general, setting aspect and autoaspect options is enough.">
                <value name="vga11"/>
                <value name="pal43"/>
                <value name="pal169"/>
                <value name="ntsc43"/>
                <value name="ntsc169"/>
                <value name="ext"/>
            </opt>
            <opt type="int" name="par_width" min="1" max="255" default="1" description="Specifies the width of the custom pixel aspect ratio."/>
            <opt type="int" name="par_height" min="1" max="255" default="1" description="Specifies the height of the custom pixel aspect ratio."/>
            <opt type="string" name="aspect" default="16/9" description="Store movie aspect internally, just like MPEG files. Much nicer solution than rescaling, because quality is not decreased.&lt;br&gt;MPlayer and a few others players will play these files correctly, others will display them with the wrong aspect. The aspect parameter can be given as a ratio or a floating point number." />
            <opt type="bool" name="autoaspect" default="false" description="Same as the aspect option, but automatically computes aspect, taking into account all the adjustments (crop/expand/scale/ etc.) made in the filter chain."/>
            <opt type="bool" name="noautoaspect" default="false" description="Same as the aspect option, but automatically computes aspect, taking into account all the adjustments (crop/expand/scale/ etc.) made in the filter chain."/>
            <opt type="bool" name="psnr" default="false" description="Print the PSNR (peak signal to noise ratio) for the whole video after encoding and store the per frame PSNR in a file with a name like ’psnr_hhmmss.log’ in the current directory.&lt;br&gt;Returned values are in dB (decibel), the higher the better."/>
            <opt type="bool" name="debug" default="false" description="Save per-frame statistics in ./xvid.dbg. (This is not the two pass control file.)" />
            <opt type="int" name="threads" default="0" min="0" max="50" description="Create n threads to run the motion estimation (default: 0).&lt;br&gt;The maximum number of threads that can be used is the picture height divided by 16."/>
        </xvid>
        <x264 options="x264encopts">
            <opt type="int" name="bitrate" min="0" max="16000" special="$VIDBR" default="$VIDBR" description="Sets the average bitrate to be used in kbits/second (default: off).&lt;br&gt;Since local bitrate may vary, this average may be inaccurate for very short videos (see ratetol). Constant bitrate can be achieved by combining this with vbv_maxrate, at significant reduction in quality."/>
            <opt type="int" name="qp" min="0" max="51" default="26" description="This selects the quantizer to use for P-frames. I- and B-frames are offset from this value by ip_factor and pb_factor, respectively. 20−40 is a useful range (default: 26).&lt;br&gt;Lower values result in better fidelity, but higher bitrates. 0 is lossless. Note that quantization in H.264 works differently from MPEG-1/2/4: H.264’s quantization parameter (QP) is on a logarithmic scale. The mapping is approximately H264QP = 12 + 6*log2(MPEGQP). For example, MPEG at QP=2 is equivalent to H.264 at QP=18"/>
            <opt type="double" name="crf" min="1.0" max="50.0" default="0" description="Enables constant quality mode, and selects the quality. The scale is similar to QP. Like the bitrate-based modes, this allows each frame to use a different QP based on the frame’s complexity."/>
            <opt type="int" name="pass" min="1" max="3" special="$PASS" default="$PASS" description="Enable 2 or 3-pass mode. It is recommended to always encode in 2 or 3-pass mode as it leads to a better bit distribution and improves overall quality.&lt;br&gt;-  1 : first pass&lt;br&gt;-  2 : second pass (of two pass encoding)&lt;br&gt;-  3 : Nth pass (second and third passes of three pass encoding)&lt;br&gt;&lt;br&gt;Here is how it works, and how to use it:&lt;br&gt;The first pass (pass=1) collects statistics on the video and writes them to a file. You might want to deactivate some CPU-hungry options, apart from the ones that are on by default.&lt;br&gt;In two pass mode, the second pass (pass=2) reads the statistics file and bases ratecontrol decisions on it.&lt;br&gt;In three pass mode, the second pass (pass=3, that is not a typo) does both: It first reads the statistics, then overwrites them. You can use all encoding options, except very CPU-hungry options.&lt;br&gt;The third pass (pass=3) is the same as the second pass, except that it has the second pass’ statistics to work from. You can use all encoding options, including CPU-hungry ones.&lt;br&gt;The first pass may use either average bitrate or constant quantizer. ABR is recommended, since it does not require guessing a quantizer. Subsequent passes are ABR, and must specify bitrate."/>
            <opt type="int" name="turbo" min="0" max="2" default="0" description="Fast first pass mode. During the first pass of a two or more pass encode it is possible to gain speed by disabling some options with negligible or even no impact on the final pass output quality.&lt;br&gt;-  0 : disabled  (default)&lt;br&gt;-  1 : Reduce subq, frameref and disable some inter-macroblock partition analysis modes.&lt;br&gt;-  2 : Reduce subq and frameref to 1, use a diamond ME search and disable all partition analysis modes.&lt;br&gt;&lt;br&gt;Level 1 can increase first pass speed up to 2x with no change in the global PSNR of the final pass compared to a full quality first pass.&lt;br&gt;Level 2 can increase first pass speed up to 4x with about +/- 0.05dB change in the global PSNR of the final pass compared to a full quality first pass."/>
            <opt type="int" name="keyint" min="0" max="1000" default="250" description="Sets maximum interval between IDR-frames (default: 250). Larger values save bits, thus improve quality, at the cost of seeking precision.&lt;br&gt;Unlike MPEG-1/2/4, H.264 does not suffer from DCT drift with large values of keyint."/>
            <opt type="int" name="keyint_min" min="0" max="1000" default="25" description="Sets minimum interval between IDR-frames (default: 25).&lt;br&gt;If scenecuts appear within this interval, they are still encoded as I-frames, but do not start a new GOP. In H.264, I-frames do not necessarily bound a closed GOP because it is allowable for a P-frame to be predicted from more frames than just the one frame before it (also see frameref). Therefore, I-frames are not necessarily seekable. IDR-frames restrict subsequent P-frames from referring to any frame prior to the IDR-frame."/>
            <opt type="int" name="scenecut" min="1" max="100" default="40" description="Controls how aggressively to insert extra I-frames (default: 40).&lt;br&gt;With small values of scenecut, the codec often has to force an I-frame when it would exceed keyint. Good values of scenecut may find a better location for the I-frame. Large values use more I-frames than necessary, thus wasting bits. -1 disables scene-cut detection, so I-frames are inserted only once every other keyint frames, even if a scene-cut occurs earlier. This is not recommended and wastes bitrate as scenecuts encoded as P-frames are just as big as I-frames, but do not reset the 'keyint counter'."/>
            <opt type="int" name="frameref" min="1" max="16" default="1" description="Number of previous frames used as predictors in B- and P-frames (default: 1).&lt;br&gt;This is effective in anime, but in live-action material the improvements usually drop off very rapidly above 6 or so reference frames. This has no effect on decoding speed, but does increase the memory needed for decoding. Some decoders can only handle a maximum of 15 reference frames."/>
            <opt type="int" name="bframes" min="0" max="16" default="0" description="maximum number of consecutive B-frames between I- and P-frames (default: 0)"/>
            <opt type="bool" name="b_adapt" default="true" description="Automatically decides when to use B-frames and how many, up to the maximum specified above (default: on).&lt;br&gt;If this option is disabled, then the maximum number of B-frames is used."/>
            <opt type="bool" name="nob_adapt" default="true" description="Automatically decides when to use B-frames and how many, up to the maximum specified above (default: on).&lt;br&gt;If this option is disabled, then the maximum number of B-frames is used."/>
            <opt type="int" name="b_bias" min="-100" max="100" default="0" description="Controls the decision performed by b_adapt. A higher b_bias produces more B-frames (default: 0)."/>
            <opt type="bool" name="b_pyramid" default="false" description="Allows B-frames to be used as references for predicting other frames.&lt;br&gt;For example, consider 3 consecutive B-frames: I0 B1 B2 B3 P4. Without this option, B-frames follow the same pattern as MPEG-[124]. So they are coded in the order I0 P4 B1 B2 B3, and all the B-frames are predicted from I0 and P4. With this option, they are coded as I0 P4 B2 B1 B3. B2 is the same as above, but B1 is predicted from I0 and B2, and B3 is predicted from B2 and P4. This usually results in slightly improved compression, at almost no speed cost. However, this is an experimental option: it is not fully tuned and may not always help. Requires bframes >= 2. Disadvantage: increases decoding delay to 2 frames."/>
            <opt type="bool" name="nob_pyramid" default="false" description="Allows B-frames to be used as references for predicting other frames.&lt;br&gt;For example, consider 3 consecutive B-frames: I0 B1 B2 B3 P4. Without this option, B-frames follow the same pattern as MPEG-[124]. So they are coded in the order I0 P4 B1 B2 B3, and all the B-frames are predicted from I0 and P4. With this option, they are coded as I0 P4 B2 B1 B3. B2 is the same as above, but B1 is predicted from I0 and B2, and B3 is predicted from B2 and P4. This usually results in slightly improved compression, at almost no speed cost. However, this is an experimental option: it is not fully tuned and may not always help. Requires bframes >= 2. Disadvantage: increases decoding delay to 2 frames."/>
            <opt type="bool" name="deblock" default="true" description="Use deblocking filter (default: on). As it takes very little time compared to its quality gain,&lt;br&gt;it is not recommended to disable it."/>
            <opt type="bool" name="nodeblock" default="false" description="Use deblocking filter (default: on). As it takes very little time compared to its quality gain,&lt;br&gt;it is not recommended to disable it."/>
            <opt name="deblock" description="The first parameter is AlphaC0 (default: 0). This adjusts thresholds for the H.264 in-loop deblocking filter. First, this parameter adjusts the maximum amount of change that the filter is allowed to cause on any one pixel. Secondly, this parameter affects the threshold for difference across the edge being filtered. A positive value reduces blocking artifacts more, but will also smear details. The second parameter is Beta (default: 0).&lt;br&gt; This affects the detail threshold. Very detailed blocks are not filtered, since the smoothing caused by the filter would be more noticeable than the original blocking.The default behavior of the filter almost always achieves optimal quality, so it is best to either leave it alone, or make only small adjustments. However, if your source material already has some blocking or noise which you would like to remove, it may be a good idea to turn it up a little bit.">
                 <subopt type="int" min="-6" max="6" default="0"/>
                 <subopt type="int" min="-6" max="6" default="0"/>
            </opt>
            <opt type="bool" name="cabac" default="true" description="Use CABAC (Context-Adaptive Binary Arithmetic Coding) (default: on). Slightly slows down encoding and decoding, but should save 10-15% bitrate.&lt;br&gt;Unless you are looking for decoding speed, you should not disable it."/>
            <opt type="bool" name="nocabac" default="false" description="Use CABAC (Context-Adaptive Binary Arithmetic Coding) (default: on). Slightly slows down encoding and decoding, but should save 10-15% bitrate.&lt;br&gt;Unless you are looking for decoding speed, you should not disable it."/>
            <opt type="int" name="qp_min" min="1" max="51" default="10" description="(ABR or two pass)&lt;br&gt;Minimum quantizer, 10−30 seems to be a useful range (default: 10)."/>
            <opt type="int" name="qp_max" min="1" max="51" default="51" description="(ABR or two pass)&lt;br&gt;maximum quantizer (default: 51)"/>
            <opt type="int" name="qp_step" min="1" max="50" default="4" description="(ABR or two pass)&lt;br&gt;maximum value by which the quantizer may be incremented/decremented between frames (default: 4)"/>
            <opt type="float" name="ratetol" min="0.1" max="100.0" default="1.0" description="(ABR or two pass)&lt;br&gt;allowed variance in average bitrate (no particular units) (default: 1.0)	"/>
            <opt type="int" name="vbv_maxrate" min="0" max="16000" default="0" description="(ABR or two pass)&lt;br&gt;maximum local bitrate, in kbits/second (default: disabled)"/>
            <opt type="int" name="vbv_bufsize" min="0" max="10000" default="0" description="(ABR or two pass)&lt;br&gt;averaging period for vbv_maxrate, in kbits (default: none, must be specified if vbv_maxrate is enabled)"/>
            <opt type="float" name="vbv_init" min="0.0" max="1.0" default="0.9" description="(ABR or two pass)&lt;br&gt;initial buffer occupancy, as a fraction of vbv_bufsize (default: 0.9)"/>
            <opt type="float" name="ip_factor" min="0.0" max="10.0" default="1.4" description="quantizer factor between I- and P-frames (default: 1.4)"/>
            <opt type="float" name="pb_factor" min="0.0" max="10.0" default="1.3" description="quantizer factor between P- and B-frames (default: 1.3)"/>
            <opt type="float" name="qcomp" min="0.0" max="1.0" default="0.6" description="(ABR or two pass)&lt;br&gt;quantizer compression (default: 0.6). A lower value makes the bitrate more constant, while a higher value makes the quantization parameter more constant."/>
            <opt type="int" name="cplx_blur" min="0" max="999" default="20" description="(two pass only)&lt;br&gt;Temporal blur of the estimated frame complexity, before curve compression (default: 20).&lt;br&gt; Lower values allow the quantizer value to jump around more, higher values force it to vary more smoothly. cplx_blur ensures that each I-frame has quality comparable to the following P-frames, and ensures that alternating high and low complexity frames (e.g. low fps animation) do not waste bits on fluctuating quantizer."/>
            <opt type="float" name="qblur" min="0" max="99" default="0.5" description="(two pass only)&lt;br&gt;Temporal blur of the quantization parameter, after curve compression (default: 0.5). Lower values allow the quantizer value to jump around more, higher values force it to vary more smoothly.&lt;br&gt;"/>
            <opt type="string" name="direct_pred" default="spatial" description="Determines the type of motion prediction used for direct macroblocks in B-frames.&lt;br&gt;-  none : Direct macroblocks are not used&lt;br&gt;-  spatial : Motion vectors are extrapolated from neighboring blocks. (default)&lt;br&gt;-  temporal : Motion vectors are interpolated from the following P-frame.&lt;br&gt;-  auto : The codec selects between spatial and temporal for each frame.&lt;br&gt;Spatial and temporal are approximately the same speed and PSNR, the choice between them depends on the video content. Auto is slightly better, but slower. Auto is most effective when combined with multipass. direct_pred=none is both slower and lower quality.">
                <value name="none"/>
                <value name="spatial"/>
                <value name="temporal"/>
                <value name="auto"/>
            </opt>
            <opt type="bool" name="weight_b" default="false" description="Use weighted prediction in B-frames. Without this option, bidirectionally predicted macroblocks give equal weight to each reference frame.&lt;br&gt;With this option, the weights are determined by the temporal position of the B-frame relative to the references. Requires bframes > 1."/>
            <opt type="bool" name="noweight_b" default="false" description="Use weighted prediction in B-frames. Without this option, bidirectionally predicted macroblocks give equal weight to each reference frame.&lt;br&gt;With this option, the weights are determined by the temporal position of the B-frame relative to the references. Requires bframes > 1."/>
            <opt name="partitions" description="Enable some optional macroblock types (default: p8x8,b8x8,i8x8,i4x4)&lt;br&gt;-  p8x8 : Enable types p16x8, p8x16, p8x8&lt;br&gt;-  p4x4 : Enable types p8x4, p4x8, p4x4. p4x4 is recommended only with subq >= 5, and only at low resolutions.&lt;br&gt;-  b8x8 : Enable types b16x8, b8x16, b8x8.&lt;br&gt;-  i8x8 : Enable type i8x8. i8x8 has no effect unless 8x8dct is enabled.&lt;br&gt;-  i4x4 : Enable type i4x4.&lt;br&gt;-  all :Enable all of the above types.&lt;br&gt;-  none : Disable all of the above types.&lt;br&gt;Regardless of this option, macroblock types p16x16, b16x16, and i16x16 are always enabled.&lt;br&gt;The idea is to find the type and size that best describe a certain area of the picture. For example, a global pan is better represented by 16x16 blocks, while small moving objects are better represented by smaller blocks.">
                    <subopt type="string" default="p8x8">
                        <value name="all"/>
                        <value name="none"/>
                        <value name=""/>
                        <value name="p8x8"/>
                    </subopt>
                    <subopt type="string" default="">
                        <value name=""/>
                        <value name="p4x4"/>
                    </subopt>
                    <subopt type="string" default="b8x8">
                        <value name=""/>
                        <value name="b8x8"/>
                    </subopt>
                    <subopt type="string" default="i4x4">
                        <value name=""/>
                        <value name="i4x4"/>
                    </subopt>
            </opt>
            <opt type="bool" name="8x8dct" default="false" description="Adaptive spatial transform size: allows macroblocks to choose between 4x4 and 8x8 DCT.&lt;br&gt; Also allows the i8x8 macroblock type. Without this option, only 4x4 DCT is used."/>
            <opt type="bool" name="no8x8dct" default="false" description="Adaptive spatial transform size: allows macroblocks to choose between 4x4 and 8x8 DCT.&lt;br&gt; Also allows the i8x8 macroblock type. Without this option, only 4x4 DCT is used."/>
            <opt type="string" name="me" default="hex" description="Select fullpixel motion estimation algorithm.&lt;br&gt;-  dia : diamond search, radius 1 (fast)&lt;br&gt;-  hex : hexagon search, radius 2 (default)&lt;br&gt;-  umh : uneven multi-hexagon search (slow)&lt;br&gt;-  esa : exhaustive search (very slow, and no better than umh)">
                <value name="dia"/>
                <value name="hex"/>
                <value name="umh"/>
                <value name="esa"/>
            </opt>
            <opt type="int" name="me_range" min="4" max="64" default="16" description="radius of exhaustive or multi-hexagon motion search (default: 16)"/>
            <opt type="int" name="subq" min="1" max="7" default="5" description="Adjust subpel refinement quality. This parameter controls quality versus speed tradeoffs involved in the motion estimation decision process. subq=5 can compress up to 10% better than subq=1.&lt;br&gt;-  1 : Runs fullpixel precision motion estimation on all candidate macroblock types. Then selects the best type. Then refines the motion of that type to fast quarterpixel precision (fastest).&lt;br&gt;-  2 : Runs halfpixel precision motion estimation on all candidate macroblock types. Then selects the best type. Then refines the motion of that type to fast quarterpixel precision.&lt;br&gt;-  3 : As 2, but uses a slower quarterpixel refinement.&lt;br&gt;-  4 : Runs fast quarterpixel precision motion estimation on all candidate macroblock types. Then selects the best type. Then finishes the quarterpixel refinement for that type.&lt;br&gt;-  5 : Runs best quality quarterpixel precision motion estimation on all candidate macroblock types, before selecting the best type (default).&lt;br&gt;-  6 : Enables rate-distortion optimization of macroblock types in I- and P-frames.&lt;br&gt;-  7 : Enables rate-distortion optimization of motion vectors and intra modes. (best)&lt;br&gt;In the above, 'all candidates' does not exactly mean all enabled types: 4x4, 4x8, 8x4 are tried only if 8x8 is better than 16x16."/>
            <opt type="bool" name="chroma_me" default="true" description="Takes into account chroma information during subpixel motion search (default: enabled).&lt;br&gt; Requires subq>=5."/>
            <opt type="bool" name="nochroma_me" default="true" description="Takes into account chroma information during subpixel motion search (default: enabled).&lt;br&gt; Requires subq>=5."/>
            <opt type="bool" name="mixed_refs" default="false" description="Allows each 8x8 or 16x8 motion partition to independently select a reference frame.&lt;br&gt;Without this option, a whole macroblock must use the same reference. Requires frameref>1."/>
            <opt type="bool" name="nomixed_refs" default="false" description="Allows each 8x8 or 16x8 motion partition to independently select a reference frame.&lt;br&gt;Without this option, a whole macroblock must use the same reference. Requires frameref>1."/>
            <opt type="bool" name="brdo" default="false" description="Enables rate-distortion optimization of macroblock types in B-frames. Requires subq>=6."/>
            <opt type="bool" name="nobrdo" default="false" description="Enables rate-distortion optimization of macroblock types in B-frames. Requires subq>=6."/>
            <opt type="bool" name="bime" default="false" description="Refine the two motion vectors used in bidirectional macroblocks, rather than re-using vectors from the forward and backward searches. &lt;br&gt;This option has no effect without B-frames."/>
            <opt type="bool" name="nobime" default="false" description="Refine the two motion vectors used in bidirectional macroblocks, rather than re-using vectors from the forward and backward searches. &lt;br&gt;This option has no effect without B-frames."/>
            <opt type="int" name="trellis" min="0" max="2" default="0" description="rate-distortion optimal quantization&lt;br&gt;-  0 : disabled (default)&lt;br&gt;-  1 : enabled only for the final encode&lt;br&gt;-  2 : enabled   during all mode decisions (slow, requires subq>=6)"/>
            <opt type="int" name="deadzone_inter" min="0" max="32" default="21" description="Set the size of the inter luma quantization deadzone for non-trellis quantization (default: 21).&lt;br&gt;Lower values help to preserve fine details and film grain (typically useful for high bitrate/quality encode), while higher values help filter out these details to save bits that can be spent again on other macroblocks and frames (typically useful for bitrate-starved encodes). It is recommended that you start by tweaking deadzone_intra before changing this parameter."/>
            <opt type="int" name="deadzone_intra" min="0" max="32" default="11" description="Set the size of the intra luma quantization deadzone for non-trellis quantization (default: 11).&lt;br&gt;This option has the same effect as deadzone_inter except that it affects intra frames. It is recommended that you start by tweaking this parameter before changing deadzone_inter."/>
            <opt type="bool" name="fast_pskip" default="true" description="Performs early skip detection in P-frames (default: enabled).&lt;br&gt;This usually improves speed at no cost, but it can sometimes produce artifacts in areas with no details, like sky."/>
            <opt type="bool" name="nofast_pskip" default="true" description="Performs early skip detection in P-frames (default: enabled).&lt;br&gt;This usually improves speed at no cost, but it can sometimes produce artifacts in areas with no details, like sky."/>
            <opt type="bool" name="dct_decimate" default="true" description="Eliminate dct blocks in P-frames containing only a small single coefficient (default: enabled).&lt;br&gt; This will remove some details, so it will save bits that can be spent again on other frames, hopefully raising overall subjective quality. If you are compressing non-anime content with a high target bitrate, you may want to disable this to preserve as much detail as possible."/>
            <opt type="int" name="nr" min="0" max="0−100000" default="0" description="Noise reduction, 0 means disabled. 100−1000 is a useful range for typical content, but you may want to turn it up a bit more for very noisy content (default: 0).&lt;br&gt;Given its small impact on speed, you might want to prefer to use this over filtering noise away with video filters like denoise3d or hqdn3d."/>
            <opt type="int" name="chroma_qp_offset" min="-12" max="12" default="0" description="Use a different quantizer for chroma as compared to luma.&lt;br&gt;Useful values are in the range -2−2 (default: 0)."/> 
            <opt type="int" name="level_idc" min="10" max="51" default="51" description="Set the bitstream’s level as defined by annex A of the H.264 standard (default: 51 - Level 5.1).&lt;br&gt;This is used for telling the decoder what capabilities it needs to support. Use this parameter only if you know what it means, and you have a need to set it."/>
            <opt type="int" name="threads" min="0" max="16" default="1" special="auto" description="Spawn threads to encode in parallel on multiple CPUs (default: 1). This has a slight penalty to compression quality.&lt;br&gt;0 or ’auto’ tells x264 to detect how many CPUs you have and pick an appropriate number of threads."/>
            <opt type="bool" name="global_header" default="false" description="Causes SPS and PPS to appear only once, at the beginning of the bitstream (default: disabled).&lt;br&gt;Some players, such as the Sony PSP, require the use of this option. The default behavior causes SPS and PPS to repeat prior to each IDR frame."/>
            <opt type="bool" name="noglobal_header" default="false" description="Causes SPS and PPS to appear only once, at the beginning of the bitstream (default: disabled).&lt;br&gt;Some players, such as the Sony PSP, require the use of this option. The default behavior causes SPS and PPS to repeat prior to each IDR frame."/>
            <opt type="bool" name="interlaced" default="false" description="Treat the video content as interlaced."/>
            <opt type="bool" name="nointerlaced" default="false" description="Treat the video content as interlaced."/>
            <opt type="bool" name="ssim" default="false" description="Print the Structural Similarity Metric results.&lt;br&gt;This is an alternative to PSNR, and may be better correlated with the perceived quality of the compressed video."/>
            <opt type="bool" name="nossim" default="false" description="Print the Structural Similarity Metric results.&lt;br&gt;This is an alternative to PSNR, and may be better correlated with the perceived quality of the compressed video."/>
	    <opt type="bool" name="visualize" default="false" description="Enable x264 visualizations during encoding. If the x264 on your system supports it, a new window will be opened during the encoding process, in which x264 will attempt to present an overview of how each frame gets encoded.&lt;br&gt;Each block type on the visualized movie will be colored as follows:&lt;br&gt;- red/pink&lt;br&gt;- intra block&lt;br&gt;- blue&lt;br&gt;- inter block&lt;br&gt;- green&lt;br&gt;- skip block&lt;br&gt;- yellow&lt;br&gt;- B-block&lt;br&gt;&lt;br&gt;This feature can be considered experimental and subject to change. In particular, it depends on x264 being compiled with visualizations enabled. Note that as of writing this, x264 pauses after encoding and visualizing each frame, waiting for the user to press a key, at which point the next frame will be encoded."/>      
        </x264>
        <lavc options="lavcopts">
            <opt type="bool" name="bit_exact" default="false" description="Use only bit exact algorithms (except (I)DCT). Additionally bit_exact disables several optimizations and thus should only be used for regression tests, which need binary identical files even if the encoder version changes.&lt;br&gt;This also suppresses the user_data header in MPEG-4 streams. Do not use this option unless you know exactly what you are doing."/>
            <opt type="int"  name="threads" min="1" max="8" default="1" description="Maximum number of threads to use (default: 1). May have a slight negative effect on motion estimation."/>
            <opt type="string" name="vcodec" default="mpeg4" description="The video codec">
                <value name="mjpeg"/>                    
                <value name="ljpeg"/>
                <value name="h261"/>
                <value name="h263"/>
                <value name="h263p"/>
                <value name="mpeg4"/>
                <value name="msmpeg4"/>
                <value name="msmpeg4v2"/>
                <value name="wmv1"/>
                <value name="wmv2"/>
                <value name="rv10"/>
                <value name="mpeg1video"/>
                <value name="mpeg2video"/>
                <value name="huffyuv"/>
                <value name="ffvhuf"/>
                <value name="asv1"/>
                <value name="asv2"/>
                <value name="ffv1"/>
                <value name="flv"/>
                <value name="dvvideo"/>
                <value name="svq1"/>
                <value name="snow"/>
            </opt>
            <opt type="float" name="lmin" min="0.01" max="255.0" default="2.0" description="Minimum frame-level Lagrange multiplier for ratecontrol (default: 2.0). Lavc will rarely use quantizers below the value of lmin.&lt;br&gt;Lowering lmin will make lavc more likely to choose lower quantizers for some frames, but not lower than the value of vqmin. Likewise, raising lmin will make lavc less likely to choose low quantizers, even if vqmin would have allowed them. You probably want to set lmin approximately equal to vqmin. When adaptive quantization is in use, changing lmin/lmax may have less of an effect; see mblmin/mblmax."/>
            <opt type="float" name="lmax" min="0.01" max="255.0" default="31.0" description="maximum Lagrange multiplier for ratecontrol (default: 31.0)"/>
            <opt type="float" name="mblmin" min="0.01" max="255.0" default="2.0" description="Minimum macroblock-level Lagrange multiplier for ratecontrol (default:2.0).&lt;br&gt;This parameter affects adaptive quantization options like qprd, lumi_mask, etc.."/>
            <opt type="float" name="mblmax" min="0.01" max="255.0" default="31.0" description="Maximum macroblock-level Lagrange multiplier for ratecontrol (default: 31.0)."/>
            <opt type="int" name="vqscale"  min="-1" max="31" default="-1" description="Constant quantizer / constant quality encoding (selects fixed quantizer mode). A lower value means better quality but larger files (default: -1).&lt;br&gt;In case of snow codec, value 0 means lossless encoding. Since the other codecs do not support this, vqscale=0 will have an undefined effect. 1 is not recommended (see vqmin for details)."/>
            <opt type="int" name="vqmin" min="1" max="8" default="2" description="minimum quantizer (pass 1/2)&lt;br&gt;-1 : Not recommended (much larger file, little quality difference and weird side effects: msmpeg4, h263 will be very low quality, ratecontrol will be confused resulting in lower quality and some decoders will not be able to decode it).&lt;br&gt;- 2 :Recommended for normal mpeg4/mpeg1video encoding (default).&lt;br&gt;- 3 : Recommended for h263(p)/msmpeg4. The reason for preferring 3 over 2 is that 2 could lead to overflows. (This will be fixed for h263(p) by changing the quantizer per MB in the future, msmpeg4 cannot be fixed as it does not support that.)"/>            
            <opt type="int" name="vqmax"  min="1" max="31" default="31" description="Maximum quantizer (pass 1/2), 10−31 should be a sane range (default: 31)."/>
            <opt type="int" name="vqdiff"  min="1" max="31" default="3" description="maximum quantizer difference between consecutive I- or P-frames (pass 1/2) (default: 3)"/>
            <opt type="int" name="vmax_b_frames" min="0" max="4" default="0" description="maximum number of B-frames between non-B-frames:&lt;br&gt;- 0 : no B-frames (default)&lt;br&gt;- 0−2 : sane range for MPEG-4"/>
            <opt type="int" name="vme" min="0" max="5" default="4" description="motion estimation method. Available methods are:&lt;br&gt;- 0	: none (very low quality)&lt;bt&gt;- 1 : full (slow, currently unmaintained and disabled)&lt;br&gt;- 2 : log (low quality, currently unmaintained and disabled)&lt;br&gt;- 3 : phods (low quality, currently unmaintained and disabled)&lt;br&gt;- 4 : EPZS: size=1 diamond, size can be adjusted with the *dia options (default)&lt;br&gt;- 5 : X1 (experimental, currently aliased to EPZS)&lt;br&gt;- 8 : iter (iterative overlapped block, only used in snow)&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: 0−3 currently ignores the amount of bits spent, so quality may be low."/>
            <opt type="int" name="me_range" min="0" max="9999" default="0" description="motion estimation search range (default: 0 (unlimited))"/>
            <opt type="int" name="mbd" min="0" max="2" default="0" description="Macroblock decision algorithm (high quality mode), encode each macro block in all modes and choose the best. This is slow but results in better quality and file size. When mbd is set to 1 or 2, the value of mbcmp is ignored when comparing macroblocks. If any comparison setting (precmp, subcmp, cmp, or mbcmp) is nonzero, however, a slower but better half-pel motion search will be used, regardless of what mbd is set to. If qpel is set, quarter-pel motion search will be used regardless.&lt;br&gt;-0 : Use comparison function given by mbcmp (default).&lt;br&gt;- 1 : Select the MB mode which needs the fewest bits (=vhq).&lt;br&gt;- 2 : Select the MB mode which has the best rate distortion."/>
            <opt type="bool" name="vhq" default="false" description="Same as mbd=1, kept for compatibility reasons."/>
            <opt type="bool" name="v4mv" default="false" description="Allow 4 motion vectors per macroblock (slightly better quality).&lt;br&gt;Works better if used with mbd>0."/>
            <opt type="bool" name="obmc" default="false" description="overlapped block motion compensation (H.263+)"/>
            <opt type="int" name="inter_threshold" min="-1000" max="1000" default="0"/>
            <opt type="int" name="keyint" min="0" max="300" default="250" description="maximum interval between keyframes in frames (default: 250 or one keyframe every ten seconds in a 25fps movie. This is the recommended default for MPEG-4).&lt;br&gt;Most codecs require regular keyframes in order to limit the accumulation of mismatch error. Keyframes are also needed for seeking, as seeking is only possible to a keyframe - but keyframes need more space than other frames, so larger numbers here mean slightly smaller files but less precise seeking. 0 is equivalent to 1, which makes every frame a keyframe. Values >300 are not recommended as the quality might be bad depending upon decoder, encoder and luck. It is a common for MPEG-1/2 to use values less or =30."/>
            <opt type="int" name="sc_threshold" min="-1000000000" max="1000000000" default="0" description="Threshold for scene change detection. A keyframe is inserted by libavcodec when it detects a scene change.&lt;br&gt;You can specify the sensitivity of the detection with this option. -1000000000 means there is a scene change detected at every frame, 1000000000 means no scene changes are detected (default: 0)."/>
            <opt type="int" name="sc_factor" min="1" max="20" default="1" description="Causes frames with higher quantizers to be more likely to trigger a scene change detection and make libavcodec use an I-frame (default: 1).&lt;br&gt;1−16 is a sane range. Values between 2 and 6 may yield increasing PSNR (up to approximately 0.04 dB) and better placement of I-frames in high-motion scenes. Higher values than 6 may give very slightly better PSNR (approximately 0.01 dB more than sc_factor=6), but noticably worse visual quality."/>
            <opt type="int" name="vb_strategy" min="0" max="2" default="0" description="strategy to choose between I/P/B-frames:&lt;br&gt;- 0 : Always use the maximum number of B-frames (default).&lt;br&gt;- 1 : Avoid B-frames in high motion scenes. See the b_sensitivity option to tune this strategy.&lt;br&gt;- 2 : Places B-frames more or less optimally to yield maximum quality (slower). You may want to reduce the speed impact of this option by tuning the option brd_scale."/>
            <opt type="int" name="b_sensitivity" min="0" max="50" default="40" description="Adjusts how sensitively vb_strategy=1 detects motion and avoids using B-frames (default: 40).&lt;br&gt;Lower sensitivities will result in more B-frames. Using more B-frames usually improves PSNR, but too many B-frames can hurt quality in high-motion scenes. Unless there is an extremely high amount of motion, b_sensitivity can safely be lowered below the default; 10 is a reasonable value in most cases."/>
            <opt type="int" name="brd_scale" min="0" max="10" default="0" description="Downscales frames for dynamic B-frame decision (default: 0). Each time brd_scale is increased by one, the frame dimensions are divided by two, which improves speed by a factor of four. Both dimensions of the fully downscaled frame must be even numbers, so brd_scale=1 requires the original dimensions to be multiples of four, brd_scale=2 requires multiples of eight, etc.&lt;br&gt;In other words, the dimensions of the original frame must both be divisible by 2^(brd_scale+1) with no remainder."/>
            <opt type="int" name="bidir_refine" min="0" max="4" default="0" description="Refine the two motion vectors used in bidirectional macroblocks, rather than re-using vectors from the forward and backward searches. This option has no effect without B-frames.&lt;br&gt;- 0 : Disabled (default).&lt;br&gt;- 1−4	: Use a wider search (larger values are slower)."/>
            <opt type="int" name="vpass" min="1" max="3" default="$PASS" special="$PASS" description="Activates internal two (or more) pass mode, only specify if you wish to use two (or more) pass encoding.&lt;br&gt;- 1 : first pass (also see turbo)&lt;br&gt;- 2 : second pass&lt;br&gt;- 3 : Nth pass (second and subsequent passes of N-pass encoding)&lt;br&gt;&lt;br&gt;Here is how it works, and how to use it:&lt;br&gt;The first pass (vpass=1) writes the statistics file. You might want to deactivate some CPU-hungry options, like 'turbo' mode does.&lt;br&gt;In two pass mode, the second pass (vpass=2) reads the statistics file and bases ratecontrol decisions on it.&lt;br&gt;In N-pass mode, the second pass (vpass=3, that is not a typo) does both: It first reads the statistics, then overwrites them. You might want to backup divx2pass.log before doing this if there is any possibility that you will have to cancel MEncoder. You can use all encoding options, except very CPU-hungry options like 'qns'.&lt;br&gt;You can run this same pass over and over to refine the encode. Each subsequent pass will use the statistics from the previous pass to improve. The final pass can include any CPU-hungry encoding options.&lt;br&gt;If you want a 2 pass encode, use first vpass=1, and then vpass=2.&lt;br&gt;If you want a 3 or more pass encode, use vpass=1 for the first pass and then vpass=3 and then vpass=3 again and again until you are satisfied with the encode."/>
            <opt type="bool" name="turbo" default="true" description="Dramatically speeds up pass one using faster algorithms and disabling CPU-intensive options.&lt;br&gt;This will probably reduce global PSNR a little bit (around 0.01dB) and change individual frame type and PSNR a little bit more (up to 0.03dB)."/>
            <opt type="string" name="aspect" default="" description="Store movie aspect internally, just like with MPEG files. Much nicer than rescaling, because quality is not decreased. Only MPlayer will play these files correctly, other players will display them with wrong aspect. The aspect parameter can be given as a ratio or a floating point number.&lt;br&gt;EXAMPLE: aspect=16/9 or aspect=1.78"/>
            <opt type="bool" name="autoaspect" default="false" description="Same as the aspect option, but automatically computes aspect, taking into account all the adjustments (crop/expand/scale/ etc.) made in the filter chain.&lt;br&gt;Does not incur a performance penalty, so you can safely leave it always on."/>
            <opt type="int" name="vbitrate" min="4" max="16000" default="$VIDBR" special="$VIDBR" description="Specify bitrate (pass 1/2) (default: 800)."/>
            <opt type="int" name="vratetol" min="1000" max="100000" default="8000" description="approximated file size tolerance in kbit. 1000−100000 is a sane range. (warning: 1kbit = 1000 bits) (default: 8000)&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: vratetol should not be too large during the second pass or there might be problems if vrc_(min|max)rate is used."/>
            <opt type="int" name="vrc_maxrate" min="0" max="16000" default="0" description="maximum bitrate in kbit/sec (pass 1/2) (default: 0, unlimited)"/>
            <opt type="int" name="vrc_minrate" min="0" max="16000" default="0" description="minimum bitrate in kbit/sec (pass 1/2) (default: 0, unlimited)"/>
            <opt type="int" name="vrc_buf_size" min="0" max="2000" default="1835" description="buffer size in kbit (pass 1/2).&lt;br&gt;For MPEG-1/2 this also sets the vbv buffer size, use 327 for VCD, 917 for SVCD and 1835 for DVD."/>
            <opt type="int" name="vrc_strategy" min="0" max="1" default="0" description="Ratecontrol method. Note that some of the ratecontrol-affecting options will have no effect if vrc_strategy is not set to 0.&lt;br&gt;- 0 : Use internal lavc ratecontrol (default).&lt;br&gt;- 1 : Use Xvid ratecontrol (experimental; requires MEncoder to be compiled with support for Xvid 1.1 or higher)."/>
            <opt type="float" name="vb_qfactor" min="-31.0" max="31.0" default="1.25" description="quantizer factor between B- and non-B-frames (pass 1/2) (default: 1.25)"/>
            <opt type="float" name="vi_qfactor" min="-31.0" max="31.0" default="0.8" description="quantizer factor between I- and non-I-frames (pass 1/2) (default: 0.8)"/>
            <opt type="float" name="vb_qoffset" min="-31.0" max="31.0" default="1.25" description="quantizer offset between B- and non-B-frames (pass 1/2) (default: 1.25)"/>
            <opt type="float" name="vi_qoffset" min="-31.0" max="31.0" default="0.0" description="(pass 1/2) (default: 0.0)&lt;br&gt;if v{b|i}_qfactor > 0 I/B-frame quantizer = P-frame quantizer * v{b|i}_qfactor + v{b|i}_qoffset&lt;br&gt;else do normal ratecontrol (do not lock to next P-frame quantizer) and set q= -q * v{b|i}_qfactor + v{b|i}_qoffset&lt;br&gt;&lt;u&br;HINT&lt;/u&gt;: To do constant quantizer encoding with different quantizers for I/P- and B-frames you can use: lmin=ip_quant:lmax=ip_quant:vb_qfactor=b_quant/ip_quant."/>
            <opt type="float" name="vqblur" min="0.0" max="99.0" default="0.0" description="Pass One: Quantizer blur (default: 0.5), larger values will average the quantizer more over time (slower change).&lt;br&gt;- 0.0 : Quantizer blur disabled.&lt;br&gt;- 1.0	: Average the quantizer over all previous frames.&lt;br&gt;&lt;br&gt;Pass Two: Quantizer gaussian blur (default: 0.5), larger values will average the quantizer more over time (slower change)."/>
            <opt type="float" name="vqcomp" min="0.0" max="1.0" default="0.5" description="Quantizer compression, vrc_eq depends upon this (pass 1/2) (default: 0.5).&lt;br&gt;For instance, assuming the default rate control equation is used, if vqcomp=1.0, the ratecontrol allocates to each frame the number of bits needed to encode them all at the same QP. If vqcomp=0.0, the ratecontrol allocates the same number of bits to each frame, i.e. strict CBR.&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: Those are extreme settings and should never be used. Perceptual quality will be optimal somewhere in between these two extremes."/>
            <opt type="int" name="vrc_init_cplx" min="0" max="1000" default="0" description="initial complexity (pass 1)"/>
            <opt type="float" name="vrc_init_occupancy" min="0.0" max="1.0" default="0.9" description="initial buffer occupancy, as a fraction of vrc_buf_size (default: 0.9)"/>
            <opt type="int" name="vqsquish" min="0" max="1" default="1" description="Specify how to keep the quantizer between qmin and qmax (pass 1/2).&lt;br&gt;- 0 : Use clipping.&lt;br&gt;- 1 : Use a nice differentiable function (default)."/>
            <opt type="int" name="vlelim" min="-1000" max="1000" default="0" description="Sets single coefficient elimination threshold for luminance. Negative values will also consider the DC coefficient (should be at least -4 or lower for encoding at quant=1):&lt;br&gt;- 0 : disabled (default)&lt;br&gt;- -4 : JVT recommendation"/>
            <opt type="int" name="vcelim" min="-1000" max="1000" default="0" description="Sets single coefficient elimination threshold for chrominance. Negative values will also consider the DC coefficient (should be at least -4 or lower for encoding at quant=1):&lt;br&gt;- 0 : disabled (default)&lt;br&gt;- 7 : JVT recommendation"/>
            <opt type="int" name="vstrict" min="-2" max="1" default="0" description="strict standard compliance&lt;br&gt;- 0 : disabled&lt;br&gt;- 1 : Only recommended if you want to feed the output into the MPEG-4 reference decoder.&lt;br&gt;- -1 : Allow libavcodec specific extensions (default).&lt;br&gt;- -2 : Enables experimental codecs and features which may not be playable with future MPlayer versions (snow)."/>
            <opt type="bool" name="vdpart" default="false" description="Data partitioning. Adds 2 Bytes per video packet, improves error-resistance when transferring over unreliable channels (e.g. streaming over the internet). Each video packet will be encoded in 3 separate partitions:&lt;br&gt;- 1. MVs movement&lt;br&gt;- 2. DC coefficients low res picture&lt;br&gt;- 3. AC coefficients details&lt;br&gt;&lt;br&gt;MV &amp; DC are most important, loosing them looks far worse than loosing the AC and the 1. &amp; 2. partition. (MV &amp; DC) are far smaller than the 3. partition (AC) meaning that errors will hit the AC partition much more often than the MV &amp; DC partitions. Thus, the picture will look better with partitioning than without, as without partitioning an error will trash AC/DC/MV equally."/>
            <opy type="int" name="vpsize" min="0" max="10000" default="0" description="Video packet size, improves error-resistance.&lt;br&gt;- 0 : disabled (default)&lt;br&gt;- 100−1000 : good choice"/>
            <opt type="bool" name="ss" default="false" description="slice structured mode for H.263+"/>
            <opt type="bool" name="gray" default="false" description="grayscale only encoding (faster)"/>
            <opt type="int" name="vfdct" min="0" max="6" default="0" description="DCT algorithm&lt;br&gt;- 0 : Automatically select a good one (default).&lt;br&gt;- 1 :  fast integer&lt;br&gt;- 2 : accurate integer&lt;br&gt;- 3 : MMX&lt;br&gt;- 4 : mlib&lt;br&gt;- 5 : AltiVec&lt;br&gt;- 6 : floating point AAN"/>
            <opt type="int" name="idct" min="0" max="9" default="0" description="IDCT algorithm&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: To the best of our knowledge all these IDCTs do pass the IEEE1180 tests.&lt;br&gt;- 0 : Automatically select a good one (default).&lt;br&gt;- 1 : JPEG reference integer&lt;br&gt;- 2 : simple&lt;br&gt;- 3 : simplemmx&lt;br&gt;- 4 : libmpeg2mmx (inaccurate, do not use for encoding with keyint >100)&lt;br&gt;- 5 : ps2&lt;br&gt;- 6 : mlib&lt;br&gt;- 7 : arm&lt;br&gt;- 8 : AltiVec&lt;br&gt;- 9 : sh4"/>
            <opt type="float" name="lumi_mask" min="0" max="1.0" default="0.0" description="Luminance masking is a ’psychosensory’ setting that is supposed to make use of the fact that the human eye tends to notice fewer details in very bright parts of the picture. Luminance masking compresses bright areas stronger than medium ones, so it will save bits that can be spent again on other frames, raising overall subjective quality, while possibly reducing PSNR.&lt;br&gt;WARNING: Be careful, overly large values can cause disastrous things.&lt;br&gt;WARNING: Large values might look good on some monitors but may look horrible on other monitors.&lt;br&gt;- 0.0 : disabled (default)&lt;br&gt;- 0.0−0.3 : sane range"/>
            <opt type="float" name="dark_mask" min="0" max="1.0" default="0.0" description="Darkness masking is a ’psychosensory’ setting that is supposed to make use of the fact that the human eye tends to notice fewer details in very dark parts of the picture. Darkness masking compresses dark areas stronger than medium ones, so it will save bits that can be spent again on other frames, raising overall subjective quality, while possibly reducing PSNR.&lt;br&gt;WARNING: Be careful, overly large values can cause disastrous things.&lt;br&gt;WARNING: Large values might look good on some monitors but may look horrible on other monitors / TV / TFT.&lt;br&gt;- 0.0 : disabled (default)&lt;br&gt;- 0.0−0.3 : sane range"/>
            <opt type="float" name="tcplx_mask" min="0" max="1.0" default="0.0" description="Temporal complexity masking (default: 0.0 (disabled)). Imagine a scene with a bird flying across the whole scene;&lt;br&gt;tcplx_mask will raise the quantizers of the bird’s macroblocks (thus decreasing their quality), as the human eye usually does not have time to see all the bird’s details. Be warned that if the masked object stops (e.g. the bird lands) it is likely to look horrible for a short period of time, until the encoder figures out that the object is not moving and needs refined blocks. The saved bits will be spent on other parts of the video, which may increase subjective quality, provided that tcplx_mask is carefully chosen."/>
            <opt type="float" name="scplx_mask" min="0" max="1.0" default="0.0" description="Spatial complexity masking. Larger values help against blockiness, if no deblocking filter is used for decoding, which is maybe not a good idea.&lt;br&gt;Imagine a scene with grass (which usually has great spatial complexity), a blue sky and a house; scplx_mask will raise the quantizers of the grass’ macroblocks, thus decreasing its quality, in order to spend more bits on the sky and the house.&lt;br&gt;HINT: Crop any black borders completely as they will reduce the quality of the macroblocks (also applies without scplx_mask).&lt;br&gt;- 0.0 : disabled (default)&lt;br&gt;- 0.0−0.5 : sane range&lt;br&gt;&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: This setting does not have the same effect as using a custom matrix that would compress high frequencies harder, as scplx_mask will reduce the quality of P blocks even if only DC is changing. The result of scplx_mask will probably not look as good."/>
            <opt type="float" name="p_mask" min="0" max="1.0" default="0.0" description="Reduces the quality of inter blocks.&lt;br&gt;This is equivalent to increasing the quality of intra blocks, because the same average bitrate will be distributed by the rate controller to the whole video sequence (default: 0.0 (disabled)). p_mask=1.0 doubles the bits allocated to each intra block."/>
            <opt type="float" name="border_mask" min="0" max="1.0" default="0.0" description="border-processing for MPEG-style encoders.&lt;br&gt;Border processing increases the quantizer for macroblocks which are less than 1/5th of the frame width/height away from the frame border, since they are often visually less important."/>
            <opt type="bool" name="naq" default="false" description="Normalize adaptive quantization (experimental).&lt;br&gt;When using adaptive quantization (*_mask), the average per-MB quantizer may no longer match the requested frame-level quantizer. Naq will attempt to adjust the per-MB quantizers to maintain the proper average."/>
            <opt type="bool" name="ildct" default="false" description="Use interlaced DCT."/>
            <opt type="bool" name="ilme" default="false" description="Use interlaced motion estimation (mutually exclusive with qpel)."/>
            <opt type="bool" name="alt" default="false" description="Use alternative scantable."/>
            <opt type="int" name="top" min="-1" max="1" default="-1" description="- -1 : automatic&lt;br&gt;- 0 : bottom field first&lt;br&gt;- 1 : top field first"/>
            <opt type="string" name="format" default="YV12" description="- YV12 : default&lt;br&gt;- 444P : for ffv1&lt;br&gt;- 422P : for HuffYUV, lossless JPEG, dv and ffv1&lt;br&gt;- 411P : for lossless JPEG, dv and ffv1&lt;br&gt;- YVU9 : for lossless JPEG, ffv1 and svq1&lt;br&gt;- BGR32 : for lossless JPEG and ffv1">
                 <value name="YV12"/>
                 <value name="444P"/>
                 <value name="422P"/>
                 <value name="411P"/>
                 <value name="YVU9"/>
                 <value name="BGR32"/>
            </opt>
            <opt type="string" name="pred" default="0" description="for HuffYUV&lt;br&gt;- 0 : left prediction&lt;br&gt;- 1 : plane/gradient prediction&lt;br&gt;- 2 : median prediction&lt;br&gt;&lt;br&gt;for lossless JPEG&lt;br&gt;- 0 : left prediction&lt;br&gt;- 1 : top prediction&lt;br&gt;- 2 : topleft prediction&lt;br&gt;- 3 : plane/gradient prediction&lt;br&gt;- 6 : mean prediction">
                <value name="0"/>
                <value name="1"/>
                <value name="2"/>
                <value name="3"/>
                <value name="6"/>
            </opt>
            <opt type="int" name="coder" min="0" max="1" default="0" description="for ffv1&lt;br&gt;- 0 : vlc coding (Golomb-Rice).&lt;br&gt;- 1 : arithmetic coding (CABAC)"/>
            <opt type="int" name="context" min="0" max="1" default="0" description="for ffv1&lt;br&gt;- 0 : small context model&lt;br&gt;- 1 : large context model&lt;br&gt;&lt;br&gt;for ffvhuff&lt;br&gt;- 0 : predetermined Huffman tables (builtin or two pass)&lt;br&gt;- 1 : adaptive Huffman tables"/>
            <opt type="bool" name="qpel" default="false" description="Use quarter pel motion compensation (mutually exclusive with ilme).&lt;br&gt;HINT: This seems only useful for high bitrate encodings."/>
            <opt type="int" name="mbcmp" min="0" max="2000" default="0" description="Sets the comparison function for the macroblock decision, has only an effect if mbd=0.&lt;br&gt;-  0 (SAD) : sum of absolute differences, fast (default)&lt;br&gt;-  1 (SSE) : sum of squared errors&lt;br&gt;-  2 (SATD) : sum of absolute Hadamard transformed differences&lt;br&gt;-  3 (DCT) : sum of absolute DCT transformed differences&lt;br&gt;-  4 (PSNR) : sum of squared quantization errors (avoid, low quality)&lt;br&gt;-  5 (BIT) : number of bits needed for the block&lt;br&gt;-  6 (RD) : rate distortion optimal, slow&lt;br&gt;-  7 (ZERO) : 0&lt;br&gt;-  8 (VSAD) : sum of absolute vertical differences&lt;br&gt;-  9 (VSSE) : sum of squared vertical differences&lt;br&gt;-  10 (NSSE) : noise preserving sum of squared differences&lt;br&gt;-  11 (W53) : 5/3 wavelet, only used in snow&lt;br&gt;-  12 (W97) : 9/7 wavelet, only used in snow&lt;br&gt;-  +256 : Also use chroma, currently does not work (correctly) with B-frames."/>
            <opt type="int" name="ildctcmp" min="0" max="2000" default="0" description="Sets the comparison function for interlaced DCT decision&lt;br&gt;(see mbcmp for available comparison functions)."/>
            <opt type="int" name="precmp" min="0" max="2000" default="0" description="Sets the comparison function for motion estimation pre pass&lt;br&gt;(see mbcmp for available comparison functions) (default: 0)."/>
            <opt type="int" name="cmp" min="0" max="2000" default="0" description="Sets the comparison function for full pel motion estimation&lt;br&gt;(see mbcmp for available comparison functions) (default: 0)."/>
            <opt type="int" name="subcmp" min="0" max="2000" default="0" description="Sets the comparison function for sub pel motion estimation&lt;br&gt;(see mbcmp for available comparison functions) (default: 0)."/>
            <opt type="int" name="nssew" min="0" max="1000000" default="8" description="This setting controls NSSE weight, where larger weights will result in more noise.&lt;br&gt;0 NSSE is identical to SSE You may find this useful if you prefer to keep some noise in your encoded video rather than filtering it away before encoding (default: 8)."/>
            <opt type="int" name="predia" min="-99" max="6" default="0" description="diamond type and size for motion estimation pre-pass"/>
            <opt type="int" name="dia" min="-99" max="6" default="0" description="Diamond type &amp; size for motion estimation. Motion search is an iterative process. Using a small diamond does not limit the search to finding only small motion vectors. It is just somewhat more likely to stop before finding the very best motion vector, especially when noise is involved. Bigger diamonds allow a wider search for the best motion vector, thus are slower but result in better quality.&lt;br&gt;Big normal diamonds are better quality than shape-adaptive diamonds.&lt;br&gt;Shape-adaptive diamonds are a good tradeoff between speed and quality.&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: The sizes of the normal diamonds and shape adaptive ones do not have the same meaning.&lt;br&gt;-  -3 : shape adaptive (fast) diamond with size 3&lt;br&gt;-  -2 : shape adaptive (fast) diamond with size 2&lt;br&gt;-  -1 : uneven multi-hexagon search (slow)&mt;br&gt;-  1 : normal size=1 diamond (default) =EPZS type diamond&lt;br&gt;0&lt;br&gt;000&lt;br&gt;0&lt;br&gt;-  2 : normal size=2 diamond&lt;br&gt;0&lt;br&gt;000&lt;br&gt;00000&lt;br&gt;000&lt;br&gt;0"/>
            <opt type="bool" name="trell" default="false" description="Trellis searched quantization. This will find the optimal encoding for each 8x8 block. Trellis searched quantization is quite simply an optimal quantization in the PSNR versus bitrate sense (Assuming that there would be no rounding errors introduced by the IDCT, which is obviously not the case.). It simply finds a block for the minimum of error and lambda*bits.&lt;br&gt;-  lambda : quantization parameter (QP) dependent constant&lt;br&gt;-  bits : amount of bits needed to encode the block&lt;br&gt;-  error : sum of squared errors of the quantization"/>
            <opt type="bool" name="cbp" default="false" description="Rate distorted optimal coded block pattern.&lt;br&gt;Will select the coded block pattern which minimizes distortion + lambda*rate. This can only be used together with trellis quantization."/>
            <opt type="bool" name="mv0" default="false" description="Try to encode each MB with MV=0,0 and choose the better one.&lt;br&gt;This has no effect if mbd=0."/>
            <opt type="int" name="mv0_threshold" min="0" max="1000" default="256" description="When surrounding motion vectors are 0,0 and the motion estimation score of the current block is less than mv0_threshold, 0,0 is used for the motion vector and further motion estimation is skipped (default: 256). Lowering mv0_threshold to 0 can give a slight (0.01dB) PSNR increase and possibly make the encoded video look slightly better; raising mv0_threshold past 320 results in diminished PSNR and visual quality. Higher values speed up encoding very slightly (usually less than 1%, depending on the other options used).&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: This option does not require mv0 to be enabled."/>
            <opt type="bool" name="qprd" default="false" description="rate distorted optimal quantization parameter (QP) for the given lambda of each macroblock"/>
            <opt type="int" name="last_pred" min="0" max="99" default="0" description="amount of motion predictors from the previous frame&lt;br&gt;-  0 : (default)&lt;br&gt;-  a :  Will use 2a+1 x 2a+1 macroblock square of motion vector predictors from the previous frame."/>
            <opt type="int" name="preme" min="0" max="2" default="0" description="motion estimation pre-pass&lt;br&gt;-  0 : disabled&lt;br&gt;-  1 : only after I-frames (default)&lt;br&gt;-  2 : always"/>
            <opt type="int" name="subq" min="1" max="8" default="1" description="subpel refinement quality (for qpel) (default: 8 (high quality))&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: This has a significant effect on speed."/>
            <opt type="bool" name="mpeg_quant" default="false" description="Use MPEG quantizers instead of H.263."/>
            <opt type="bool" name="aic" default="false" description="Enable AC prediction for MPEG-4 or advanced intra prediction for H.263+. This will improve quality very slightly (around 0.02 dB PSNR) and slow down encoding very slightly (about 1%).&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: vqmin should be 8 or larger for H.263+ AIC."/>
            <opt type="bool" name="aiv" default="false" description="alternative inter vlc for H.263+"/>
            <opt type="bool" name="umv" default="false" description="unlimited MVs (H.263+ only) Allows encoding of arbitrarily long MVs."/>
            <opt type="int" name="ibias" min="-256" max="-256"  default="0" description="intra quantizer bias (256 equals 1.0, MPEG style quantizer default: 96, H.263 style quantizer default: 0)&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: The H.263 MMX quantizer cannot handle positive biases (set vfdct=1 or 2), the MPEG MMX quantizer cannot handle negative biases (set vfdct=1 or 2)."/>
            <opt type="int" name="pbias" min="-256" max="-256"  default="0" description="inter quantizer bias (256 equals 1.0, MPEG style quantizer default: 0, H.263 style quantizer default: -64)&lt;br&gt;&lt;u&gt;NOTE&lt;/u&gt;: The H.263 MMX quantizer cannot handle positive biases (set vfdct=1 or 2), the MPEG MMX quantizer cannot handle negative biases (set vfdct=1 or 2).&lt;br&gt;&lt;u&gt;HINT&lt;/u&gt;: A more positive bias (-32 − -16 instead of -64) seems to improve the PSNR."/>
            <opt type="int" name="nr" min="0" max="100000"  default="0" description="Noise reduction, 0 means disabled.&lt;br&gt;0−600 is a useful range for typical content, but you may want to turn it up a bit more for very noisy content (default: 0). Given its small impact on speed, you might want to prefer to use this over filtering noise away with video filters like denoise3d or hqdn3d."/>
            <opt type="int" name="qns" min="0" max="3"  default="0" description="Quantizer noise shaping. Rather than choosing quantization to most closely match the source video in the PSNR sense, it chooses quantization such that noise (usually ringing) will be masked by similar-frequency content in the image. Larger values are slower but may not result in better quality. This can and should be used together with trellis quantization, in which case the trellis quantization (optimal for constant weight) will be used as startpoint for the iterative search.&lt;br&gt;-  0 : disabled (default)&lt;br&gt;-  1 : Only lower the absolute value of coefficients.&lt;br&gt;-  2 : Only change coefficients before the last non-zero coefficient + 1.&lt;br&gt;-  3 : Try all."/>
            <opt type="bool" name="vqmod_amp" default="false" description="experimental quantizer modulation"/>
            <opt type="bool" name="vqmod_freq" default="false" description="experimental quantizer modulation"/>
            <opt type="string" name="dc" default="8" description="intra DC precision in bits (default: 8).&lt;br&gt;If you specify vcodec=mpeg2video this value can be 8, 9, 10 or 11.">
                <value name="8"/>
                <value name="9"/>
                <value name="10"/>
                <value name="11"/>
            </opt>
            <opt type="bool" name="cgop" default="false" description="Close all GOPs. Currently it only works if scene change&lt;br&gt;detection is disabled (sc_threshold=1000000000)."/>
            <opt type="int" name="vglobal" min="0" max="3" default="0" description="Control writing global video headers.&lt;br&gt;-  0 : Codec decides where to write global headers (default).&lt;br&gt;-  1 : Write global headers only in extradata (needed for .mp4/MOV/NUT).&lt;br&gt;-  2 : Write global headers only in front of keyframes.&lt;br&gt;-  3 : Combine 1 and 2."/>
            <opt type="int" name="level" min="0" max="100" default="0" description="Set CodecContext Level. Use 31 or 41 to play video on a Playstation 3."/>
        </lavc>
    </VIDEO>
</OPTIONS>